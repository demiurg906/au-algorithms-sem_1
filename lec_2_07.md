## Задача о максимальном потоке

Популярная *задача о максимальном потоке*: есть сеть -- взвешенный ориентированный граф с весами-пропускными способностями и двумя выделенными вершинами -- стоком и истоком. Требуется расставить потоки на каждом ребре, чтобы поток, приходящий в сток бы максимальным.

Пропускная способность ребра $(u, v)$ -- $C_{uv}\geq 0$

Поток:
* $f: E\rightarrow \mathbb{R}_+$
* $f_{uv}\geq 0$
* $f_{uv}\leq C_{uv}$
* $\forall v\in V\setminus\{s,t\}\ \ \sum\limits_{(u, v)\in E} f_{uv} = \sum\limits_{(v, u)\in E} f_{vu}$
* $|f| = \sum\limits_{(s, u)\in E} f_{su} = \sum\limits_{(v, t)\in E} f_{vt}$
* Задача: $|f|\rightarrow \max$

Данная задача сводится к задаче линейного программирования.

1. $f_{uv}\geq 0$
2. $f_{uv}\leq c_{uv}$
3. $\sum\limits_{uv} f_{uv} - \sum\limits_{vu}f_{vu} = 0$, *Законы Кирхгофа*
4. $\sum\limits_{su}f_{su}\rightarrow\max$

Равенства из пункта 3. можно превратить в неравенства, введя фейковые переменые $f_{uv}+s_{uv}=c_{uv}$

### Наивный алгоритм

Находим какой-нибудь путь из $s$ в $t$ и пускаем по нему максимально возможный поток. Повторяем, пока можно.

Данный подход плох, т.к. мы можем выбрать какой-нибудь неоптимальный путь, и, тем самым, обрубить возможности для других путей.

### Алгоритм Форда-Фалкерсона

[Описание](https://neerc.ifmo.ru/wiki/index.php?title=%D0%90%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC_%D0%A4%D0%BE%D1%80%D0%B4%D0%B0-%D0%A4%D0%B0%D0%BB%D0%BA%D0%B5%D1%80%D1%81%D0%BE%D0%BD%D0%B0,_%D1%80%D0%B5%D0%B0%D0%BB%D0%B8%D0%B7%D0%B0%D1%86%D0%B8%D1%8F_%D1%81_%D0%BF%D0%BE%D0%BC%D0%BE%D1%89%D1%8C%D1%8E_%D0%BF%D0%BE%D0%B8%D1%81%D0%BA%D0%B0_%D0%B2_%D0%B3%D0%BB%D1%83%D0%B1%D0%B8%D0%BD%D1%83) на neerc.ifmo.

Для каждого ребра заведем два потока -- один идет в прямом направлении, другой в обратном.

Пусть $f$ -- некоторый поток в графе $G$. **Остаточная сеть** (граф на вершинах $G$) $G_f = (V, E_f)$:
1. $(u, v)\in E,\ f_{uv}<c_{uv}\Rightarrow (u,v)\in E_f,\ \tilde{c}_{uv} = c_{uv} - f_{uv}$
2. $(u, v)\in E,\ f_{uv} > 0\Rightarrow (v, u)\in E_f,\ \tilde{c}_{vu} = f_{uv}$
3. Все остальные ребра нулевые

**Идея:** пусть есть поток $f$ в обычной сети. Найдем поток $\tilde{f}$ в дополняющей сети.

Пусть $\bar{f} = f + \tilde{f}$. Тогда $\bar{f}_{uv} = f_{uv}+\tilde{f}_{uv} - \tilde{f}_{vu}$

**$\bar{f}$ является потоком:**
1. $\bar{f}_{uv}\geq 0$, т.к. $\bar{f}_{uv}\geq f_{uv} - \tilde{f}_{vu}\geq f_{uv}-f_{uv} = 0$
2. $\bar{f}_{uv}\leq c_{uv}$, т.к. $\bar{f}_{uv}\leq f_{uv} + \tilde{f}_{uv}\leq f_{uv}-\tilde{c}_{uv} = f_{uv} + c_{uv}-f_{uv} = c_{uv}$
3. Законы Кирхгофа: выполняется для $f$ и $\tilde{f}\ \Rightarrow$ выполняется для $\bar{f}$

**Схема алгоритма:**
1. Начинаем с $f=0$
2. Пока в дополняющей сети есть путь $\pi:s\leadsto t$, пустим по пути $\pi$ максимальный поток $\tilde{f}$ в $G_f$ и пересчитываем поток $f = f + \tilde{f}$

#### Разрез в графе

Разбиение множества вершины на две непресекающихся части $c:\ V = S\sqcup T$ называется разрезом.
Размером разреза называется сумма пропускных способностей ребер, из $S$ в $T$. $|c| = \sum\limits_{u\in S,\ v\in T}c_{uv}$.

**Теорема о разрезе:** размер максимального потока в графе равняется размеру минимального разреза
**Доказательство:**
1. $|f|\leq|c|$. Очевидно проистекает из законов Кирхгофа. Простыми словами, через разрез не может протечь поток больший, чем разрешают ребра. Есть тонкий момент, что в разрезе мы учитываем не все ребра, но это обходится, если аккуратно расписать законы Кирхгофа.
2. Пусть $f$ такой, что нет пути $s\leadsto t$ в остаточной сети $G_f$. Построим разрез $c:\ \ |c| = |f|$.
    Рассмотрим две компоненты:
    1. $S$ -- все вершины, доступные из $s$ в $G_f$
    2. $T$ -- все остальные
    Утверждается, что $|c = (S, T)| = |f|$.
    1. $(u, v)\in E,\ u\in S,\ v\in T$ Тогда $f_{uv} = c_{uv}$, т.е $\tilde{c}_{uv} = 0$. Если бы это было не так, то можно было бы насытить его и увеличить поток
    2. $(v, u)\in E,\ u\in S,\ v\in T$ Тогда $f_{vu} = 0$, т.е. $\tilde{c}_{uv} = 0$.
    Таким образом $|f| = \sum f_{su} = \sum f_{uv} - \sum f_{vu} = \sum c_{uv} = |c|$

**Вывод:** если Форд-Фалкерсон завершился, то максимальный поток найден.

**Замечания:**
1. задача о минимальном $(S, T)$ разрезе:
    - задача линейного программирования
    - двойственная к задаче о максимальном потоке
2. на иррациональных $c_{uv}$ ФФ может не завершиться
3. в голом варианте ФФ может работать очень долго

### Задача о поиске паросочетания в двудольном графе

Задача -- найти максимальное паросочетание в двудольном графе. Данная задача просто сводится к поиску максимального потока: добавляем к долям сток и исток, ориентируем все ребра слева направо, у всех ребер пропускные способности -- единички. Ищем максимальный поток, удаляем добавленные ребра, победа.

### Алгоритм Эдмондса-Карпа

Минусы алгоритма Форда-Фалкерсона:

* при больших пропускных способностях алгоритм перестает быть полиномиальным
* при иррациональных весах алгоритм может не завершиться

Т.к. алгоритм Ф.Ф. не идеален, был придумал *алгоритм Эдмондса-Карпа* ([neerc.ifmo](http://neerc.ifmo.ru/wiki/index.php?title=%D0%90%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC_%D0%AD%D0%B4%D0%BC%D0%BE%D0%BD%D0%B4%D1%81%D0%B0-%D0%9A%D0%B0%D1%80%D0%BF%D0%B0)).

**Суть:** в схеме ФФ ищем кратчайший по количеству ребер путь в остаточной сети (поиском в ширину) $\Rightarrow$ алгоритм работает для вещественных весов и полиномиально.

**Лемма:** пусть расстояние $D_i(v)$ -- количество ребер от $s$ до $v$ в остаточной сети на $i$-й итерации. Тогда $\forall i\ \ D_i(v) \geq D_{i-1}(v)$
**Доказательство:** от противного. Допустим, что на итерации $i$ вершина $v$ приблизилась к $s$. Тогда $v$ -- ближайшая к $s$ вершина, которая приблизилась. Пусть $(u, v)$ -- ребро на этом пути.
1. $D_i(v) = D_i(u) + 1$
2. $D_i(v) < D_{i-1}(v)$
3. $D_i(u) \geq D_{i-1}(u)$

**Утверждение:** ребро $(u, v)$ не содержалось в $C_{f_{i-1}}$
**Доказательство:** от противного. Пусть было $D_{i-1}(v) \leq D_{i-1}(u) + 1 \leq D_i(u) + 1 = D_i(v)$. Конфликт с пунктом 1 из леммы.

<span style="color:red">тут произошла магия, которую я упустил</span>

$D_{i-1}(v) + 1 = D_{i-1}(u)$

$D_i(v) = D_i(u) + 1 \geq D_{i-1}(u) + 1 = D_{i-1} + 2$. Противоречие, лемма доказана.

**Теорема:** алгоритм Э.К. работает за $O(VE^2)$.
**Доказательство:** рассмотрим кратчайшее ребро на $i$-ой итерации -- это минимальное ребро на дополняющем пути минимальной пропускной способности. Больше этого ребра по потоку не послать, и при этом после пускания по нему потока оно уходит из остаточной сети: если $(u, v)$ -- критическое на итерации $i$, то $(u, v)\notin G_{f_{i + 1}}$

**Утверждение:** каждое ребро не может быть критическим более $\frac{|V|}2$ раз.
**Доказательство:** пусть $(u, v)$ критическое на итерациях $t_1$ и $t_2$. Тогда $D_{t_1}(u) + 1 = D_{t_1}(v)$ и $D_{t_2}(u) + 1 = D_{t_2}(v)$. Тогда существует $t':\ \ t1 < t' < t_2$ такое, что $(v, u)$ лежало в дополняющем пути. Т.е. $D_{t'}(v) + 1 = D_{t'}(u)$.

$D_{t_2}(v)= D_{t_2}(u) + 1 \geq D_{t'}(u) + 1 = D_{t'}(v) + 2 \geq D_{t_1}(v) + 2$. Таким образом каждый раз к $D_i(v)$ прибавляется как минимум двойка и $D_t(v) \leq |V| \Rightarrow$ каждое ребро критическое не больше $\frac{|V|}2$ раз.

Всего итераций $\leq \frac{|V|}2\cdot |E| 2 = O(VE)$ и каждая итерация занимает $O(V + E)$ (кратчайший путь ищем поиском в ширину). Итого получаем, что суммарное время $O(VE^2)$
