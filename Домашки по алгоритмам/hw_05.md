# Алгоритмы и структуры данных, ДЗ №5

Новожилов Дмитрий, гр. 504

done: 1, 2, 3, 4
left: 5, 6*

---

## №1

1. Алгоритм, детерминировано и однозначно находящий представление числа в скошенной бинарной системе счисления:
    ```python
    def is_power(n, power=0):
        # Проверяет, является ли число степенью двойки
        if n != int(n):
            return False, power
        n = int(n)
        if n == 1:
            return True, power
        elif n >= 2:
            return is_power(n / 2.0, power + 1)
        else:
            return False, power


    def splay_binary(x):
        res = []
        # максимальная длина числа
        k = math.ceil(math.log2(x + 2)) - 1
        while x > 0:
            is_pow, power = is_power(x + 2)
            if is_pow and power - 1 == k:
                res.append(2)
                k -= 1
                break
            one = 2 ** k - 1
            if one <= x:
                res.append(1)
                x -= one
            else:
                res.append(0)
            k -= 1
        for _ in range(k):
            res.append(0)
        return res
    ```
    2. Храним положение двойки в числе (если двойки нет, то считаем, что она находится справа от числа (1101..2)). Само число храним в массиве.
2. Храним положение двойки в числе (если двойки нет, то считаем, что она находится справа от числа (1101..2)). Само число храним в массиве.
    1. если слева от двойки стоит единица, то саму двойку меняем на ноль, единицу меняем на двойку.
    2. если слева от двойки стоит ноль, то ноль меняем на единицу, двойку меняем на ноль
    3. если слева от двойки ничего нет, то двойку меняем на ноль, слева дописываем единицу
    Этот алгоритм легко прослеживается, если взглянуть на первые n натуральных чисел в данной системе счисления.

## №2

1. Смотрим на высоты первых двух бинарных деревьев.
    1. Они разные. Кладем новый элемент в новое бинарное дерево высоты 1.
    2. Они одинаковые. Первые два дерева заменяются одним, с новым элементом в корне и с этими деревьями в качестве детей.
2. Идем по корням всех деревьев до тех пор, пока не найдем нужное дерево:
    ```python
    tree = first_tree()
    while i < tree.height:
        i -= tree.height
        tree = next_tree()
    ```
    Далее, если хранить бинарные деревья в массивах, то достаточно просто вернуть `tree[i]` (i уже обрезано до значений, лежащих в одном дереве). Если нет, то можно идти по дереву вправо или влево в зависимости от того, больше i чем половина высоты дерева или меньше (если `i = 1`, то элемент лежит в корне дерева).
    **Определение элемента по индексу в дереве:** пусть $n-1$ -- количество элементов в дереве. В корне лежит элемент с индексом 1. В левом поддереве лежат элементы с индексами $[2; n/2]$, в правом -- $[n/2, n-1]$. Тогда для нахождения элемента с индексом $i$ можно применить следующий алгоритм:
    ```python
    def find(i, root):
        if i == 1:
            return root.value
        n = 2 ** root.h  # каждое дерево знает свою высоту
        if i <= n // 2:
            return find(i - 1, root.left)
        else:
            return find(i - n // 2, root.right)
    ```
    Т.к. самих деревьев не больше чем $\log n$ и высота каждого дерева не больше $\log n$, то и время работы $O(\log n)$.
3. Идем по деревьям справа налево. Пока `k` больше высоты дерева, добавляем это дерево в новый список (слева), уменьшаем `k` на высоту. Если `k` меньше высоты дерева, то из этого дерева выбираем самое правое поддерево высоты `k` и добавляем его слева в новый список. Оценка сложности та же, что и в предыдущем пункте.
    **Почему получится скошенный список:** можно представить удаление первого элемента из списка как процедуру, обратную добавлению -- либо удалаяется дерево размера 1, либо из крайнего дерева удаляется вершина, а его дети становятся отдельными деревьями в наборе. Нетрудно заметить, что набор деревьев, полученный в результате удаления первых `n-k` элементов совпадает по построению с тем набором деревьев, который получается в результате работы вышеописанного алгоритма.

## №3

Имеется два массива `a` и `b` (гаек и болтов). Сортируем их с помощью быстрой сортировки, опорным элементом выбираем гайку, при `partition` перемещаем болты, гайку перемещаем в то место, на котором оказался соответствующий ей болт. Потом выбираем болт, соответствующий выбранной гайке, относительно него перемещаем гайки. Вызываемся рекурсивно для подмассивов. Время работы $O(n \log n)$, т.к алгоритм представляет из себя два QuickSort, каждый из которых работает за $O(n\log n)$. Т.к. каждой гайке соотвествует один болт (и наоборот), то в результате первого `partition` опорные гайка и болт встанут на свое место, и при втором `partition` они уже не поменяют свое положение, поэтому сортировка не сломается.

## №4

1. На полностью отсортированном массиве результат всегда равен `True` в силу корректности работы бинарного поиска.
2. Пусть "хорошие" и "плохие" элемент -- это элементы, которые находятся (не находятся) бинарным поиском.
    **Утверждение:** пусть массив не отсортирован. `i = bin_search(x)`, `j = bin_search(y)`, $i < j$ $\Rightarrow$ $x \leq y$.
    *Док-во:* для каждого ключа $x$ есть последовательность $x_1..x_k, \ k = O(\log n)$ элементов, с которыми он сравнивается. Для любой пары ключей эта последовательность имеет хотя бы один общий член ($l$ членов в общем случае). По алгоритму бинарного поиска $x < x_l = y_l < y$ (индекс $x$ меньше индекса $y$).

    **Утверждение:** в не почти-отсортированном массиве минимум 10% элементов плохие.
    *Док-во:* предположим обратное. Тогда, если удалить все <10% плохих элементов, среди оставшихся любая пара будет упорядочена $\Rightarrow$ массив почти-отсортированный. Противоречие.

    **Доказательство пункта:**
    Массив отсортирован меньше чем на 90%. Вероятность алгоритму наткнуться на "плохой" элемент $P = 1 - \left(\frac 9{10}\right)^k > \frac 23 \Rightarrow k > \frac{\ln 1/3}{\ln 9/10} \approx 10.4$.
