# Алгоритмы и структуры данных, ДЗ №11

Новожилов Дмитрий, гр. 504

---

## №2

1. Корректность алгоритма Дейкстры основывается на утверждении, что если для какой-то вершины был найден минимальный путь, то из всех вершин, которые достижимы из данных и еще не обработаны не может найтись пути, короче, чем найденный. Для нашей метрики с двоичными числами жто утверждение работает.
    Действительно, если мы нашли минимальную строчку для какой-то вершины, то для всех остальных вершин (не обработанных) строчки будут либо с таким же числом и большим числом нулей, либо с большим числом. А из таких строчек получить строчку меньше, чем данную приписыванием нолика или единички невозможно.
2. Алгоритм Флойда не сработает. Рассмотрим граф ![граф](images/hw_11_2_2.png)
    Для определенности, пусть алгоритм выглядит таким образом:
    ```python
    for i in range(1, n + 1):
        for u in range(1, n + 1):
            for v in range(1, n + 1):
                d[u][v] = min(d[u][v], d[u][i] + d[i][v])
    ```
    Некоторые расстояния после шага `i=4`:
    ```
    d[1][4] = inf
    d[1][5] = '1'
    d[5][4] = '000'
    ```
    Далее, на шаге `i=5` будет произведена следующая релаксация: `d[1][4] = min(inf, '1' + '000') = '1000'`, алгоритм завершится, и расстояние между вершинами 1 и 4 будет `'1000'`. Однако на самом деле минимальное расстояние между этими вершинами -- это `'11'`.
3. Если посмотреть на [доказательство](https://neerc.ifmo.ru/wiki/index.php?title=%D0%90%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC_%D0%A4%D0%BE%D1%80%D0%B4%D0%B0-%D0%91%D0%B5%D0%BB%D0%BB%D0%BC%D0%B0%D0%BD%D0%B0) корректности алгоритма Форда-Беллмана, то можно заметить, что оно строится на утверждениях, что $d[k][u] = \min\limits_{v:\ vu\in E}(d[k-1][v] + \omega(u, v))$ и $d'[u]=\min(d'[u], d'[v]+\omega(vu))$. Для нашей метрики эти равенства, очевидно, корректны.

    Также в данном графе нет отрицательных циклов, что гарантирует, что алгоритм корректно посчитает все растояния за $V$ итераций.

## №3

Рассмотрим все кратчайшие пути. Если какой-то путь состоит только из возрастающих вершин, либо же сначала из возрастающих, потом убывающих ($(v_1, v_{k_1},...,v_{k_i}, v_{l_1}, ..., v_{l_j}), v_{k_i} \uparrow, v_{l_j} \downarrow$), то такой путь найдется за одну итерацию алгоритма. Если путь состоит из нескольких ($k$) таких участков, на которых меняется возрастание-убывание вершин, то он найдется за $k$ итераций алгоритма (за первую отыщется расстояние для первго участока $\uparrow\downarrow$, за вторую -- для второго и т.д.).
В графе на $n$ вершинах самый длинный короткий путь может состоять из $n$ вершин. В худшем случае, участки возрастания и убывания номеров вершин будут длины 1 ($v_1, v_n, v_2, v_{n-1}...$), тогда для нахождения такого пути потребуется $\frac n2$ итераций алгоритма, ч.т.д.
