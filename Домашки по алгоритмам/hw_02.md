# Алгоритмы и структуры данных, ДЗ №2

Новожилов Дмитрий, гр. 504

---

## №1

Проверка, является ли расстояние d ответом: первую корову ставим в первое стойло, дальше следующее выбираем на расстоянии не меньше, чем d от предыдущего. Время работы -- O(m)

Бин. поиск по ответу d: минимальное расстояние -- 0, максимальное расстояние -- $x_{max}$

## № 2

**Теорема Akra–Bazzi**:
$T(x) = g(x) + \sum \limits_{i=1}^{k} a_i T(b_ix + h_i(x))$
$h_i(x) = O\left(\frac x {(\log x)^2}\right)$
$\exists \ p: \sum \limits_{i=1}^{k} a_ib_i^p = 1$

$T(x) = \Theta\left(x^p + \left(1 + \int\limits_1^x \frac{g(u)}{u^{p+1}} du\right)\right)$

**Задача**:

$T(n) = T(\alpha n) + T((1 - \alpha)n) + n$
$\alpha^p + (1 - \alpha)^p = 1 \Rightarrow p = 1$

$T(n) = \Theta\left(n\left(1 + \int \frac n {n^2} dn\right)\right) = \Theta \left(n \log n\right)$


## № 3

Дерево отрезков -- дерево, вершины которого представляют из себя массивы, в которых хранится, сколько каждое число массива встречается на отрезке $[l, r]$, а дочерние элементы которого хранят ту же информацию, но для отрезков $[l, m]$ и $[m+1, r]$, где $m = \frac{l + r} 2$. Корень дерева хранит информацию о всем массиве ($[0, n]$).
Строится это дерево за $O(n \log n)$: считается левый ребенок, правый ребенок, затем они за линию сливаются. Сложность построения листьев -- $O(1)$.
Высота дерева $h = \log n$

Ответ на запрос формируется таким образом: данный отрезок $[l, r]$ рекурсивно разбивается на кусочки, из которых состоит дерево, из данных в соответствующих вершинах которых собирается ответ. Сложность -- $O(\log n)$, т.к. такова высота дерева.

## № 4

1. Подойдет сортировка вставками (для каждого элемента ищется подходящее место среди ранее упорядоченных элементов). Т.к. каждый патрон удален от своего места не более, чем на k позиций, то при сортировке он подвинет порядка k элементов, соответственно сложность алгоритма $O(nk)$
2. Подойдет сортировка пузырьком. Каждый элемент сдвинется только на столько позиций, в скольки иневерсиях он учавствует. Т.о. всего будет произведено $O(n+I)$ действий.
3.
4. Можно отсортировать массив сортировкой деревом, в качестве бинарного дерева поиска используя красно-черное дерево, которое гарантирует сложность вставки элемента $O(\log n)$ (вставляем все элементы в дерево, поле чего вытаскиваем отсортированный массив обходом в глубину). При вставке элемента в дерево происходит m сравнений, где m зависит от того, насколько удален вставляемый элемент от тех, что уже есть в дереве. Т.к. в данном массиве каждый элемент удален от своего места не далее чем на k позиций, то при вставке его в дерево произойдет порядка $\log k$ сравненией, т.к. на большую глубину элементу не придется опускаться. Таким образом время, уходящее на обработку одного элемента -- $O(\log k)$, соответственно сложность алгоритма -- $O(n\log k)$

Т.к. в условии нет ограничений на дополнительную память, то можно отсортировать массив за $\Theta(\max(a))$, используя $\Theta(\max(a))$ дополнительной памяти с помощью сортировки подсчетом, что даст хорошую производительность на массивах, длинна которых превосходит максимальное значение в массиве (или мы знаем какую-то дополнительную информацию об элементах, напрмер все значения начинаются с 1000 и соседние элементы сильно не превосходят друг друга).

## № 7

Помимо файла с данными `input`, используем три дополнительных файла -- `buf_1`, `buf_2`, `output`. `n` -- количество данных в `input`. Если `2^m-1 < n < 2^m`, то дозаписываем в конец `input` бесконечности, до размера `2^m` и запоминаем их число, `n=2^m`. В памяти заводим переменную `k`, в которой хранится тикущий размер сортируемых кусков. Сначала `n=1`. Пока `input` не кончится, вставляем в `buf_1` и `buf_2` последовательные куски размера `k`, после чего сливаем их в файл `output` (как в простой сортировке слиянием). После того, как данные в `input` кончились, в `output` хранится сколько-то отсортированных по возрастанию кусков размера `2k`. Увеличиваем `k` в два раза, меняем местами `input` и `output` (мысленно, или свапом переменных), после чего повторяем эту же операцию.
После сортировки удаляем лишние бесконечности, если они были добавлены на этапе подготовки.

## № 8

Пусть точки харанятся в массиве пар.
Сначала точки в массиве сортируются в естесственном порядке ($a_i < a_j \Leftrightarrow x_i < x_j \ \text{или} \ x_i = x_j, \ y_i < y_j$).
После сортировки запускается рекурсивная функция, которая делит следующее:
Точки разбиваются на два множества $A_1$ и $A_2$, относительно прямой $x = x_m$, $m = \frac {l+r}2$, для этих двух частей рекурсивно ищутся ответы (две точки и минимальное расстояние между ними = h). h выбирается как минимум из двух ответов $h = \min(h_1, h_2)$. После этого ищутся пары точек, лежащих в разных множествах, и расстояие между ними должно быть меньше h. Для этого рассматриваются точки, отстающие от прямой раздела на расстояние меньше h ($|x_i - x_m| < h$) -- множество B. В этом множестве для каждой точки нас интересуют те точки, которые отстоят от данной по y не более чем на h. Таким образом, если отсортировать все точки множества B по y,то для каждой точки из множества B нужно проверять лишь несколько точек лежащих в массиве B перед ней. Проверив все такие пары, возможно найдется пара, с расстоянием меньшим, соответсвенно h надо будет обновить.
Если в функцию приходит множество, точек в котором мало (3 или меньше), то ближайшую пару можно найти простым перебором за константное время.
