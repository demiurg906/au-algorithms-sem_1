# Алгоритмы и структуры данных, ДЗ №12

Новожилов Дмитрий, гр. 504

---

## №2

Отсортируем все заказы в порядке возрастания $r_i$, $t_i$, если $r_i$ совпадает. Заведем очередь с приоритетом, в которую можно складывать неоконченные заказы, ключом будет являться $d_i$ -- сколько времени на них осталось потратить. Пойдем по отсортированным $r_i$. Когда встречаем очередной заказ $i$ возможны две ситуации:
1. Текущего активного заказа нет $\Rightarrow$ начинаем выполнять заказ $i$.
2. Уже выполняется заказ $k$. Тогда сравниваем времена, когда закончатся заказы $i$ и $k$: $e_i = r_i + t_i$, $e_k = r_i + d_k$. Тот заказ, у которого $e$ больше, кладем в очередь.
Помимо $r_i$ временными отметками будут служить времена окончания каждого заказа: добавили в очередь на исполнение заказ $i$, сейчас обрабатывается заказ $k$. Если новых заказов не будет, то он будет готов ко времени $e_k$. Если $e_k<r_{i+1}$, то в момент времени $e_k$ вытащим из очереди следующий заказ и начнем его исполнять.

Почему работает: очевидно, что если не простаивать, то последний заказ завершится в одно и то же время, вне зависимости от того, в каком порядке над ними работали. Значит, для минимизации $\sum e_i$ нужно, чтобы как можно больше заказов завершалось как можно раньше. Данный алгоритм этим и занимается -- в каждый момент времени ведется работа над заказом, который завершится раньше всех остальных (с учетом уже потраченного на них времени).

**Update:** рассмотрим ситуацию, когда осталось всего два заказа, $k$ и $l$, для завершения работы работы над ними нужно $d_k$ и $d_l$ времени соответственно, текущий момент времени -- $t$. Если сначала закончить заказ $k$, а потом $l$, то сумма $E_1 = e_k + e_l = t + d_k + (t + d_k + d_l) = 2\cdot t + (d_k + d_l) + d_k$. Если же сначала закончить заказ $l$, то $E_2 = e_k + e_l = 2\cdot t + (d_k + d_l) + d_l$. $E_1 - E_2 = d_k - d_l$. Очевидно, что $E_1 < E_2 \Leftrightarrow d_k < d_l$ и наоборот $\Rightarrow$ выгоднее делать тот заказ, на окончание работ над которым уйдет меньше времени. Очевидным образом это обобщается на случай произвольного числа заказов.

Время работы: сортировка -- $O(n\log n)$. Число временных отметок -- $O(2n) = O(n)$ (по одной временной отметке на старт работы и конец работы). Время операций над очередью -- $O(\log n)$. В каждый шаг над очередью проводится всего одна операция $\Rightarrow$ суммарное время работы -- $O(n \log n)$.

## №3

Считаем, что в $b_i$ учитывается время возращения курьера назад на производство. В противном случае $b_i \rightarrow 2\cdot b_i$.

Хочется распределить заказы так, чтобы курьер как можно меньше ждал, пока заказ для отправки будет готов. Тогда, если заказы выполняются непрерывно, то время доставки последнего заказа также минимизируется.

Отсортируем все заказы по возрастанию $b_i-a_i$ -- дополнительного времени, которое остается на производство к тому моменту, как заказ $i$ будет доставлен, и будем работать над заказами в этом порядке.

Таким образом мы минимизировали время ожидания курьера (если это возможно, к моменту возвращения курьера на склад следующий заказ уже готов), соответсвенно, минимизировали время доставки послденего заказа.

Время работы -- $O(n\log n + n) = O(n \log n)$.

## №4

1. 
2. Допустим, что есть символ с кодом длины 1. Тогда он будет левым листом у корня в дереве Хаффмана. Пусть его частота равна $f_x \leq \frac 13$. Тогда справа от корня будет два поддерева $T_1$ и $T_2$. По построению дерева $f_{T_1} + f_{T_2} \leq f_x \Rightarrow f_{T_1} + f_{T_2} + f_x \leq \frac 9 {10} < 1$. Противоречие.
