## Strongly connected components

**Утверждения:**
* Если рассматривать любой *ациклический граф*, то в нем есть сток и исток
* Граф $G$ ациклический тогда и только тогда, когда $G^R$ (граф с перевернутыми стрелками) тоже ациклический (и наоборот, если есть цикл в одном графе, то есть и в другом)
* $G^R$ можно построить за $O(|V|+|E|)$ по $G$, заданному списком смежности.

**Компонента сильной связности** — это максимальное подвключение подмножества $V$ такое, что $\forall u, v \in V$ существует путь $u\rightarrow v \rightarrow u$.

**Метаграф** — граф, в котором все компоненты сильной связности заменены на единичные вершины (с сохранением ребер между компонентами). Если есть несколько ребер между двумя компонентами, то, в зависимости от задачи, можно либо их склеить в одно ребро, либо оставить все.

**Утверждение:** — метаграф ациклический.
**Доказательство:** — если бы в нем был цикл, то несколько компонент сильной связности склеились бы в одну.

**Утверждение:** — есть две вершины $U$ и $V$ (в метаграфе), которые задают две компоненты сильной связности, $(U \rightarrow V) \in H$ ($H$ — множество ребер метаграфа).
    $\max\limits_{u \in U}\{post[u]\} > \max\limits_{v \in V}\{post[v]\}$ ($post$ — время выхода из вершины при обходе DFS).
**Доказательство:**
1. Сначала попали в $U \rightarrow$ ОК (у одной из вершин $u$ время выхода будет больше, чем для всех $v$)
2. Сначала попали в $V \rightarrow$ не попали в $U$ (туда попадем только на следующем вызове DFS $\rightarrow$ для всех $u$ время выхода больше любого времени $v$).

**Утверждение:** вершина с максимальным $post$ лежит в компоненте истоке.

**Утверждение:** если отсортировать вершины по убыванию $post$, то получится топологическая сортировка на метаграфе.

**Алгоритм:** отсортируем вершины по убыванию $post$ и запустим обычный поиск компонент связности в перевернутом графе.

```python
def scc(g):
    dfs(g)
    g_r = revert(g)
    sort(g_r.v, maxpost, reverse=True)  # сортируем вершины графа g_r
    # можно получить отсортированный массив прямо внутри dfs
    cc(g_r)  # поиск компонент
```

Время работы $O(|V| + |E|)$ (можно использовать сортировку подсчетом, что сортировать за $O(|V|)$).

## Кратчайшие пути

### Поиск в ширину

```python
def bfs(g, w):  # w — вершина, откуда запускаем обход
    q = deque()
    dist = [inf for v in g.f]  # массив расстояний
    prev = [0 for v in g.f]    # восстановление пути
    dist[w] = 0
    q.append(v)
    while q:
        v = q.popleft()
        for u in g.v[v].neighbours:
            if dist[u] < inf:
                dist[u] = dist[v] + 1
                prev[u] = v
                q.append(u)
    return dist, prev
```

Время работы $O(|V| + |E|)$

**Утверждение:** $\forall u: \ d[u] = \text{dist}(w, u)$
**База:** $u=w \Rightarrow d[w] = \text{dist}(w, w) = 0$
**И.п.:** верно на расстояниях $\leq k \Rightarrow$ верно на расстоянии $k+1$. Все вершины на расстоянии $k+1$ являются соседями вершин на расстоянии $k$ (достаточно очевидно).

**Утверждение:** пусть $\Pi = (v, v_1, v_2,\ ...\ ,v_k, u)$ — кратчайший путь $v \rightarrow u$. Тогда для $\forall i, j: \ i < j:\ \Pi'=(v_i, v_{i+1},\ ...\ , v_j)$ — кратчайший путь $v_i\rightarrow v_j$.

BFS Не работает для поиска кратчайшего пути, если граф взвешенный.

Можно добавить фиктивных вершин (ребро веса 5 — четыре дополнительных вершины веса 1 на это ребро).
Минусы:
* требует целых/дробных весов
* не работает на иррациональных числах (на это пофиг, т.к. иррациональность не представима на машине Тьюринга)
* требует много памяти на ребрах с большим весом

### Алгоритм Дейкстры

Работает для графов с неотрицательными ребрами.

Для реализации нужна очередь с приоритетами с операциями:
* `extract_min()`
* `change_priority(value, key)`
* `insert(value, priority)`

```python
def dijkstra(g, s):  # s — стартовая вершина
    dist = [inf for v in g.v]
    prev = [0 for  in g.v]
    dist[s] = 0
    q = priority_queue()
    q.insert(s, 0)
    while q:
        v = q.extract_min()
        for u in g.v[v].neighbours:
            if dist[u] == inf:
                dist[u] = dist[v] + g.w[v]
                prev[u] = v
                q.insert(u, dist[u])
            elif dist[u] > dist[v] + g.w[v]:
                dist[u] = dist[v] + g.w[v]
                prev[u] = v
                q.change_priority(u, dist[u])
            # если запилить такую очередь, что каждое value
            # представлено только 1 раз, и q.insert в случае
            # чего перезапишет старый приоритет, то можно
            # обойтись только одним if'ом
    return dist, prev
```

**Лемма:** алгоритм Дейскстры корректен. $\forall u: \ d[u] = \text{dist}(w, u)$.
**Доказательство:**
* Для вершин из другой компоненты связности корректность очевидна.
* Ведем три множества:
    1. $S$  — вершины, которые мы уже обработали (которые вытащили из очереди)
    2. $R$  — вершины, которые сейчас в очереди
    3. $T$  — вершины, с расстоянием равным $+\infty$

    Вершины в $R$ — соседи вершин из $S$.

    **Утверждение:** если $v$ переходит из $R$ в $S \Rightarrow \ d[v] = \text{dist}(s, v)$

    **Доказательство:** пусть $v$ — вершина в очереди с самым маленьким приоритетом.

    **И.п.:**  для всех вершин в $S$ расстояние вычисленно корректно. Докажем от противного: пусть $\Pi = (s, v1, \ ... \, v_k, v)$ — более короткий путь $s\rightarrow v$. Рассмотрим первую вершину этого пути, которая лежит в $R$. Расстояние от нее до $s$ больше, чем предпологаемое расстояние до $v$, которое лежит в очереди. Противоречие.

Сложность алгоритма: $O(|V|) + O(|V|\cdot \text{insert}) + O(|V|\cdot \text{extract_min}) + O(|E|\cdot \text{change_priority})$

Если брать очередь на куче, то сложность $O((V+E)\log V)$.
Если брать очередь на массиве, то сложность $O(V^2+E)$ (если граф простой, то $+E$ можно пренебречь).

Для неплотных $\left(E = O\left(\frac{V^2}{\log V}\right)\right)$ графов лучше использовать кучу, для плотных ($E \thicksim V^2$) — массив.

**Tip:** можно улучшить, если использовать $d$-ичную кучу. $d \approx \frac EV$.
