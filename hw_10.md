# Алгоритмы и структуры данных, ДЗ №10

Новожилов Дмитрий, гр. 504

done: 1 (0.5), 3, 4
left: 1 (0.5), 2, 5

---

## №1

**Выдержка из конспекта лекций:**

* Ведем три множества:
    1. $S$  — вершины, которые мы уже обработали (которые вытащили из очереди)
    2. $R$  — вершины, которые сейчас в очереди
    3. $T$  — вершины, с расстоянием равным $+\infty$
    Вершины в $R$ — соседи вершин из $S$.
    **Утверждение:** если $v$ переходит из $R$ в $S \Rightarrow \ d[v] = \text{dist}(s, v)$
    **Доказательство:** пусть $v$ — вершина в очереди с самым маленьким приоритетом.
    **И.п.:**  для всех вершин в $S$ расстояние вычисленно корректно. Докажем от противного: пусть $\Pi = (s, v1, \ ... \, v_k, v)$ — более короткий путь $s\rightarrow v$. Рассмотрим первую вершину этого пути, которая лежит в $R$. Расстояние от нее до $s$ больше, чем предпологаемое расстояние до $v$, которое лежит в очереди. Противоречие.

**Конец выдержки** (см. [полную версию](https://demiurg906.github.io/au-conspectus/lec_09.html#%D0%90%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC-%D0%94%D0%B5%D0%B9%D0%BA%D1%81%D1%82%D1%80%D1%8B))

При доказательстве корректности алгоритма использовался тот факт, что если вершина находится в множестве $S$, то расстояние до нее однозначно минимально и больше никогда не изменится, поэтому все вершины обрабатываются по разу.
Если же есть отрицательные ребра, то может существовать путь из одной вершины множества $S$ в другую через множества $R$ или $T$ за счет этих ребер. В таком случае, если обновилось расстояние до какой-то вершины из мн-ва $S$ (чего не могло быть в случае положительных ребер), нужно заново пересчитать все расстояния от этой вершины, что, собственно, и реализует данный алгоритм.

## №3

Можно построить лабиринт, похожий на [H дерево](https://en.wikipedia.org/wiki/H_tree). Тогда при прохождении лабиринта на каждом шаге в очередь будет добавляться 2-4 новых ячейки, соответственно, масиамльный размер очереди будет $\approx n^2$.
 $\frac{n}{n^2} \rightarrow 0 \Rightarrow n^2 = \omega(n)$

## №4

С помощью алгоритма Прима на бинарной куче ищем минимальное остовное дерево до тех пор, пока в нем не окажутся искомые три вершины из $T$. После этого в найденном дереве запускаем DFS из одной из вершин из $T$, и удаляем все пути, которые не связывают вершины $T$.

Время работы: Прим -- $O(E\log V)$, DFS -- $O(V)$, суммарное время работы $O(E\log V + V) = O(E\log V)$.

## №5

1. Подойдет Дейкстра, в массиве расстояний храним то самое максимальное ребро, с учетом этого ребра делаем релаксацию. Работает, т.к. мы посещаем вершину, связанную с уже пройденнными ребром минимального веса, то ребра меньше уже не будет (мы ж минимальное выбрали).
