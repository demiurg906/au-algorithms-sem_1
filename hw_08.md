# Алгоритмы и структуры данных, ДЗ №8

Новожилов Дмитрий, гр. 504

---

## №1

Профиль -- битовая маска, показывающая как можно разместить королей в одно столбце.
Т.к. король бьет все клетки вокруг себя, в любом профиле не может встретиться дух подряд идущих единиц. Пусть $p(n)$ -- количество профилей размера $n$. Число профилей с единицей на $n$-ой позиции =$f(n-2)$ (на $n-1$ позиции обязательно стоит $0$), с нулем на $n$-й позиции -- $f(n-1) \Rightarrow f(n) = f(n-1) + f(n-2)$.
Т.о. число различных профилей растет с той же скоростью, что и числа фиббоначи.
Теперь можно заранее посчитать все профили, которых будет $O(F_n)$ штук, и при проходе динамики по профилю перебирать лишь только посчитанные профили, а не все $2^n$ штук. Т.о. сложность алгоритма будет $O\left(n(F_n)^2\right)$.

## №2

Конь может прыгнуть через два столбца, соответственно профилем будет битовая маска, покрывающая два столбца.

Рассмотри столбцы $c_1, c_2, c_1', c_2'$ и соответствующие им профили $p_1$ и $p_2$. $d[p_1][p_2]$ (можно ли из $p_1$ перейти в $p_2$) равняется единице только если $c_2 = c_1'$ и кони в этих профилях не бьют друг друга. Если оба эти условия не выполняются, то $d[p_1][p_2] = 0$.
Всего профилей $4^n$, но переходов из каждого профиля в следующие не более $2^n$ (можно выбрать лишь те профили, у которых $c_1' = c_2$) $\Rightarrow$ матрица $d[p_1][p_2]$ очень разрежена, и, для ускорения работы алгоритма, можно хранить ее в виде списков смежности $d'[p]$. Тогда формула для подсчета количества состояний превращается в $a[i][j] = \sum\limits_{k\in d'[j]}a[i-1][k]\cdot d[k][j]$. Время подсчета такой суммы $O(2^n)$, всего таких сумм для фиксированного $i$ -- $4^n$, различных $i$ -- $n$ штук $\Rightarrow$ время работы алгоритма $O(n\cdot 2^n\cdot 4^n) = O(n\cdot 8^n)$

## №5

```python
from math import inf, ceil

n = int(input())
# a[i] -- количество кубов в сумме c_1 + ... + c_m = i
a = [inf for _ in range(n + 1)]

# максимально возможный корень
# ceil, для того, чтобы избежать ошибок округления (e.g 1000 * 1/3 < 10)
sq_n = int(ceil(n ** (1/3)))

# начальные значения
for i in range(sq_n + 1):
    i_cube = i**3
    if i_cube <= n:
        a[i*i*i] = 1

# O(n)
for i in range(n + 1):
    # O(n ** 1/3)
    for k in range(sq_n):
        if a[i] < inf:
            j = i + k ** 3
            if j > n:
                continue
            a[j] = min(a[j], a[i] + 1)

print(a[n])

# суммарное время O(n ** 4/3)
```

## №6

Исходная последовательность элементов выражения -- $c[i]$

В процессе динамики будем заполнять две матрицы -- $T[i][j]$ и $F[i][j]$: число расстановок скобок на отрезке исходной последовательности $[i, j]$ таких, что результат равен $True$ или $False$ соответственно.

$T[i][i] = 1 \text{ if } c[i] == \text{ True else } 0$
$T[i][j] = \left|\left\{i<k<j \ \ | \ \ T[i][k]\cdot T[k+1][j] = True \right\}\right|\text{если на месте k стояло И или ИЛИ} + $
$+ \left|\left\{i<k<j \ \ | \ \ T[i][k]\cdot F[k+1][j] = True \right\}\right|\text{если на месте k стояло НЕ}$

Аналогично вычисляется $F[i][j]$.

Ответ будет храниться в $T[1][n]$.

Время вычисления одного элемента $T$ или $F$ -- $O(n)$.
Всего элементов в $T$ и $F$ -- $2n^2 \Rightarrow$ время работы алгоритма $O(n^3)$.

## №7

$c[n]$ -- стоимость продажи стержня длины $n$.

Пусть в массиве $d[n]$ хранится максимальная прибыль, которую можно получить, продав стержень длины $n$. Если посчитанны все $d$ до $n-1$, то $d[n] = \max(c[1] - a + d[n-1], c[2] - a + d[n-2],\ ...\ , c[n-1] - a + d[1], c[n])$. Можно привести к более красивому виду, если положить, что $d[0] = a$: $d[n] = \max\limits_{i=1}^{n}(c[i] - a + d[n - i])$.

Время вычисления одного элемента $d[n]$ -- $O(n)$, число элементов -- $n \Rightarrow$ время работы алгоритма $O(n^2)$.
