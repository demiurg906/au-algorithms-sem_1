## Кратчайшие пути в графах с отрицательными весами

**Утверждение:** в случае, если есть ребра отрицательного веса, то кратчайшие пути могут быть не определены (если есть отрицательный цикл, то по нему можно бесконечно долго наматывать).

### Алгоритм Беллмана-Форда

*Алгоритм Беллмана-Форда* -- хороший алгоритм (вы ведь понимаете, что такие фразочки я вставляю только ради ссылок на вики, да?).


**Релакация ребра:** $e = (u\rightarrow v)$. $dist[v] = \min(dist[v], dist[u] + \omega(e))$.

**Утверждения:**
1. $dist[v]\geq dist(s, v)$
2. Пусть $s\rightarrow v_1\rightarrow ...\rightarrow v_k\rightarrow v$ -- оптимальный путь от $s$ до $v$. Если $dist[v_k]$ -- оптимальный, то после релаксации $(v_k\rightarrow v)\ \ dist[v]$ тоже становится оптимальным.
3. Пусть $e_1...e_k$ -- это ребра кратчайшего пути от $s$ до $v$. Если последовательно прорелаксировать ребра $e_1..e_k$, то мы вычислим оптимальный путь до $v$.

**Идея алгоритма:** давайте $V-1$ раз прорелаксируем все ребра.

**Утверждение:** если на какой-то итерации ничего не изменилось -- найдены все минимальные пути.

```python
def bellman_ford(g, s):
    V = len(g.v)
    dist = [inf for _ in range(V)]
    prev = [0 for _ in range(V)]

    dist[s] = 0
    for i in range(V - 1):
        for (u, v) in g.e:  # итерируемся по ребрам
            if dist[v] > dist[u] + w(u, v):
                dist[v] = dist[u] + w(u, v)
                prev[v] = u
    # тут опущена оптимизация из последнего утверждения
    return dist
```

**Время работы:** $O(V\cdot E)$. Если граф плотный, то $E\sim V^2$, и время работы $O(V^3)$.

**Утверждение:** работает в случае отрицательных ребер (в предыдущих утверждениях мы никак не использовали положительность ребер)

#### Поиск отрицательного цикла

**Утверждение:** если в алгоритме Форда-Беллмана сделать на одну итерацию больше, то тогда и только огда отрицательный цикл существует, если на этой последней итерации массив $dist$ как-то изменился. Доказательство очевидно.

### Алгоритм Флойда-Уоршала

Про данный алгоритм можно почитать на [вики](https://ru.wikipedia.org/wiki/%D0%90%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC_%D0%A4%D0%BB%D0%BE%D0%B9%D0%B4%D0%B0_%E2%80%94_%D0%A3%D0%BE%D1%80%D1%88%D0%B5%D0%BB%D0%BB%D0%B0) или на [neerc.ifmo](http://neerc.ifmo.ru/wiki/index.php?title=%D0%90%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC_%D0%A4%D0%BB%D0%BE%D0%B9%D0%B4%D0%B0).

**Основная идея:** ищем кратчайшие пути между всеми парами вершин. $V$ раз релаксируем всевозможные пары вершин, получаем ответ.

**Время работы:** $O(V^3)$

### Алгоритм Джонсона

Про данный алгоритм можно почитать на [вики](https://ru.wikipedia.org/wiki/%D0%90%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC_%D0%94%D0%B6%D0%BE%D0%BD%D1%81%D0%BE%D0%BD%D0%B0) или на [neerc.ifmo](http://neerc.ifmo.ru/wiki/index.php?title=%D0%90%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC_%D0%94%D0%B6%D0%BE%D0%BD%D1%81%D0%BE%D0%BD%D0%B0).

**Основная идея:** хитрый алгоритм, ищет все попарный расстояния. Сначала с помощью Беллмана-Форда (от произвольной вершины) находятся некие $h$ для каждого ребра, через которые вычисляются дельты для каждого ребра, которые делают все ребра положительными, но при этом сохраняют кратчайшие пути. Полсе этого для каждой верины запускается обычный Дейкстра.

**Время работы:** зависит от реализации очереди внутри Дейкстры. Возможны варианты $O(V^2\log V + VE)$ (на фиббоначиевой куче) и $O(VE\log V)$ (на обычной куче). Для разреженных графов работыет быстрее, чем Флойд-Уоршал.
