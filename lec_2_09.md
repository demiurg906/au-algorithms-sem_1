# Суффиксные структуры

## Суффиксное дерево

Пусть есть слово `s = bananas$` (`$` -- служебный символ, который не встречается в исходной строке).
Тогда его суффиксы:
```
s1 = bananas$
s2 = ananas$
s3 = nanas$
s4 = anas$
s5 = nas$
s6 = as$
s7 = s$
s8 = $
```

*Суффиксное дерево:* строим бор, в котором хранятся все эти суффиксы. Благодаря `$` в конце, все терминалы -- листья. Размер бора -- $O(n^2)$.

Зачем нужно: если есть шаблон $p$, то его поиск в тексте $s$ будет работать за $O(|p|) = O(m)$, т.е. мы получаем отсутствие зависимости от длины исходного текста.

Проблема: квадрат памяти -- это очень грустно.

**Хинт (сжатое суффиксное дерево):** все цепочки ребер между вершинами, у которых один ребенок, можно схлопнуть в одно ребро (о ребру на цепочку), каждое ребро будет представлять тот кусок строки, который матчится по этой цепочке. Физически на ребрах храним индексы начала и конца подстроки, которой соответствует ребро. Получаем дерево размера $O(n\cdot |\Sigma|)$, т.к. количество вершин с разветвлениями равняется количеству суффиксов исходной строки (т.е. всего вершин не более чем $2n$).

Множитель $|\Sigma|$ все портит (хоть и не так сильно, как $n^2$), т.к. хотим работать с очень большими текстами. Это можно обойти, если в вершине хранить не массив размера алфавита, а мапу. Тогда получим память $O(n)$ и поиск $O(n\log|\Sigma|)$ в случае древовидной мапы или $O(m)$ в случае мапы на крутых хешах.

**Факт:** существует линейный алгоритм построения суффиксного дерева за $O(n)$ (например, алгоритм Укконнена (<i>количество букв "н" неопределено</i>)).

**Еще факт:** можно найти все вхождения $p$ за $O(|p| + \#\text{вхождений})$ -- прикладываем шаблон и потом пробегаем по терминальным вершинам, которые остались болтаться.

**Гипотеза (Кнут):** наибольшую общую подстроку $T_1$ и $T_2$, где $|T_1| = |T_2| = n$ нельзя вычислить быстрее $\Omega(n\log n)$. Эта гипотеза **НЕВЕРНА**, <i>лол</i>.

Построим суффиксное по тексту $s = t1\#t2\$$. Получим СД, в котором посередине есть ребра с $\#$, а в конце терминалы с $\$$. Если же есть какой-то терминал с $\$$, который не проходит через $\#$, то это значит, что эта подстрока есть и в $T_1$, и в  $T_2$. Дальше dfs'ом можно найти самый глубокий (по сумме длин ребер, не по количеству вершин) лист с долларом до решетки, он и будет соответствовать самой длинной общей подстроке. В итоге получим время $O(n)$.

**Минус СД:** даже с оптимизациями требует $\approx c\cdot n$ памяти для довольно большой $c$, т.к. мы храним дерево, а ноды дерева несут в себе кучу дополнительной информации, к тому же все ноды разупорядоченно хранятся в куче. Для больших текстов это очень критично.

## Суффиксный массив

**Идея:** давайте лексикографически отсортируем все суффиксы. Получим *суффиксный массив*.

**Утверждение:** суффиксный массив можно вычислить за $O(n)$, например, построив дерево и потом по нему пробежаться (в боре все отсортировано), получим $O(n\cdot |\Sigma|)$. Поразрядная сортировка не работает

**Факт:** суффиксный массив можно построить за честные $O(n)$ (просто смиритесь с этим). Алгоритм, вроде как, называется <i>scew алгоритм</i>, можно посмотреть в лекциях Максима Бобенко (CS Club).

**Алгоритм** построения суффиксного массива за $O(n\log n)$. Алгорим итеративный, имеется $\log n$ операций.
Предварительная подготовка: дописываем $\$$ (считаем что он больше любой буквы). Мысленно дополняем все строки пробелами до длины $2^k  >= n$. Суффиксы мы никак не храним, т.к. на любой суффикс можно посмотреть, имея исходную строку
Нулевая итерация: сортируем все суффиксы по первой букве (подсчетом) за $O(n)$.
$i$-ая итерация: к началу итерации суффиксы отсортированы по первым $2^{i-1}$ букве, следовательно каждому кусочку длины $2^{i-1}$ мы сопоставили какой-то номер (согласно их текущем порядку). Хочется отсортировать такого же размера куски. Фишка в том, что что порядок этих кусков внутри суффиксов мы уже знаем. Если есть суффикс $s_i$, то второй его кусок размера $2^{i-1}$ соответствует суффиксу $s_{\min(i+2^{i-1}, n)}$. **Суффикс суффикса -- это суффикс исходной строки, вот**.

Можно перефразировать так: на каждой итерации мы сортируем подсчетом, но на каждой итерации меняется размер алфавита. На $i$-й итерации мы получаем алфавит $|\Sigma|^{2^i}$. Но в сортировке у нас при этом всего два разряда.

### Поиск по суффиксным массивам

**Наивный поиск:** есть шаблон $p$ длины $m$, можно найти совпадения за $O(m\cdot\log n)$ бинарным поиском по суффиксам.

**Крутой алгоритм:** $O(m + \log n)$ (ищем одно совпадение). Алгоритм представляет из себя из себя хитрый бинарный поиск:
```python
def find(P, L, R, l, r):
    # P -- шаблон
    # L и R -- левая и правая границы
    M = ... # суффикс посередине между L и R
    # lcp(S1, S2) -- наибольший общий префикс строк S1 и S2
    # что за l и r мы передали:
    # l = len(lcp(L, P))
    # r = len(lcp(P, R))
    l` = len(lcp(L, M))
    r` = len(lcp(M, R))
    if l` > r`:
        if l` > l:
            find(P, M, R, l, r)
        elif l` < l:
            find(P, L, M, l, r)
        else:
            m = ... # количестов символов, которые совпали у P
            # c куском M, который не свпадает с L
            # P[l + 1, l + m] = M[l + 1, l + m]
            find(P, M, R, l + m, r)
    else:
        # все симметрично
```

**LCP:** хитрый алгоритм AAKLP, который после линейного предподсчета позволяет вычислять `lcp` для суффиксов за $O(1)$. Еще можно заранее предподсчиать все `lcp` для всех `L`, `R` и `M` за линию.

Время работы $O(m + \log n)$, т.к. по каждому символу шаблона мы пройдемся не более чем два раза.
