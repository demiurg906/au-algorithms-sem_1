# Алгоритмы и структуры данных, ДЗ №9

Новожилов Дмитрий, гр. 504

---

## №1

Тут подойдет бин. поиск по ответу. Отсортируем ребра, будем идти по ним бин. поиском. Условие проверки: есть ли цикл, в котором есть это ребро, и вес всех остальных ребер в цикле не больше данного (в модификации DFS для поиска цикла можно просто игнорировать ребра с бОльшим весом); если цикл есть, то пробуем найти цикл с более тяделым ребром, иначе с более легким.

## №2

Любое ребро $e$ разбивает дерево на два поддерева ($T_1$ и $T_2$). В этих поддеревьях $V_1$ и $V_2$ вершин соответственно. Тогда количество путей, проходящих через $e$ $p_e = V_1\cdot V_2 = V_1\cdot(V - V_1)$ (путь начинается в какой-то вершине из $T_1$ и заканчивается в $T_2$).
Алгоритм: поиском в глубину для каждого ребра из текущей вершины в дочерние считаем число вершин в поддереве, висящем на этом ребре, дальше считаем ответ для ребра по формуле.
Время работы $O(V)$, т.к. в алгоритме всего один DFS.

## №3

Идем из вершины $q$ до вершины $r$, на каждом шаге меняя родителя.
Реализовать это можно, например так:

```python
def rescale(g, q):
    v = q
    i = 10
    while g[v] != -1 and i > 0:
        print(v, g[v])
        v, g[v] = g[v], v
        i -= 1
    g[q] = -1
```
