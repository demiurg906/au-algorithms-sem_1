# Жадные алгоритмы

## Задача о выборе заявок

**Вход:** $\{[s_i, f_i)\} \ \ s_i < f_i$ -- список задач
Нужно найти максимальное (по количеству) множество непересекающихся задач.
**Утверждение:** жадный алгоритм находит оптимальное решение.
**Алгоритм:** отсортируем множество задач по возрастанию $f_i$. Пока задачи не кончились, берем первую задачу, выкидываем все, которые с ней пересекаются, продолжаем (вместо выкидывания, каждую следующую задачу можно сравнивать с последней добавленной).
**Время работы:** $O(n\log n)$  в общем случае, $O(n)$, если можно использовать линейную сортировку.
**Особенность:** первая задача всегда входит в ответ
**Доказательство корректности:** допустим, что есть решение лучше, но без задачи №1. Тогда можно заменить первую задачу этого решения на задачу №1, и результат будет не хуже. По индукции это распостроняется на все последующие задачи из решения, полученного алгоритмом.

## Выполнимость Хорновских формул

Хорновская формула (*Дизъюнкт Хорна*) -- подмножество булевских формул, конъюнкция дизъюнкций с не более, чем с одним положительным литералом:
1. ($\overline x$ **or** $\overline y$ **or** $\overline z$)
2. (x **and** y) $\rightarrow$ z, соответствует ($\overline x$ **or** $\overline y$ **or** $z$)
    $\rightarrow$ импликация
    слева от стрелки может ничего не быть, $\rightarrow z = (z)$ (по логике логиков, это сокращение)

$\Phi$ = ($\overline x$ **or** $\overline y$ **or** $\overline z$) **and** (($x$ **and** $y$) $\rightarrow \ z$) -- пример

**Задача:** найти подстановку переменных, при котором формула выполняется.
Если нет дизъюнктов из одного элемента, то подходит вариант "все нули". В противном случае решение может как существовать, так и не существовать.
**Алгоритм:**
$\overrightarrow x = (x_1, ..., x_n)$ -- все переменные.
Пусть $\overrightarrow x = \overrightarrow 0$ -- выполним все дизъюнкты первого типа.
Пока есть невыполненные дизъюнкты второго типа "(...) $\rightarrow x_i$" меняем $x_i=\text{true}$.
Проверяем, если $\Phi(\overrightarrow x) = \text{true}$, то $\overline x$ -- решение. В противном случае решений нет.
**Время работы:** $O(n\cdot m)$, где $n$ -- число дизъюнктов, $m$ -- длина самого большого дизъюнкта.
**Утверждение:** любая переменная, которой присвоили true будет истинной в любом управляющем наборе.
Доказывается по индукции: на первом шаге выставляются в true все термы $\rightarrow z$ (они, очевидно, всегда true). Далее, если какой-то терм нарушается, то он имеет вид ($x_a$ **and** $x_b$ **and** $x_c) \rightarrow x_d$. Тогда $x_a=x_b=x_c=\text{true} \ \Rightarrow x_d=\text{true}$

<!-- Из этого утверждения следует корректность алгоритма (воспринимается тяжеловато). -->

Почему этот алгоритм корректен? Если он возвращает набор значений, то все условия выполнены по построению. Так что надо лишь убедиться в том, что если алгоритм не находит выполняющего набора, то его действительно не существует. Это так, потому что благодаря недоверчивости алгоритма сохраняется следующий инвариант: <i>если для некоторого множества переменных установлено true, то они должны иметь значение true в любом выполняющем наборе значений</i>.
Таким образом, если значения переменных после выхода из цикла не удовлетворяют какой-то отрицательной дизъюнкции, то выполняющего набора значений вообще не существует.

## Кодирование Хаффмана

Кто же не слышал про *коды Хаффмана*?

Вход: $\{f_i\}$ -- частоты встречаемости букв алфавита
Выход: $\{c_i\}$ -- коды букв, т.ч.
1. Коды prefix-free (их можно сконкатенировать и потом спокойно восстановить результат)
2. $\sum|c_i|\cdot f_i$ минимальна

Строим бинарное дерево, где в листьях лежат буквы. Идем от корня влево -- добавляем к коду 0, вправо -- 1.

**Утверждение:** любому prefix-free коду соотв. такое бинарное дерево и наоборот.

**Утверждение:** в оптимальном дереве (соответствующему оптимальному коду) нет вершин с одним ребенком.
**Доказательство:** можно выкинуть это ребро (до вершины с одним ребеноком), тогда для всех потомков данной вершины длина кода уменьшится, преффиксность сохранится $\rightarrow$ мы найдем коды лучше.

**Утверждение:** в оптимальном дереве вершины минимальной частоты лежат на самом нижнем уровне.
**Доказательство:** пусть $f_i$ -- одна из самых редких частот. Попробуем повестить $i$ куда-нибудь в серединку, а какое-нибудь $k$ из середины повесим вниз. Тогда $f_i\cdot|c_i| + f_k\cdot|c_k|$ будет больше, чем если поменять местами $c_i$ и $c_k$ (если элемент в середине, то его $c$ меньше, чем на дне).

**Алгоритм:** кладем все символы с их частотами в ноды дерева, который складируем в очередь с приортитетами по встречаемости. Пока в очереди более одного элемента, берем два элемента из очереди с самыми малыми частотами, на их основе делаем ноду, у которой эти два элемента будут детьми (побольше -- влево, поменьше -- вправо), частота этой ноды равна сумме частот детей. Кладем эту ноду в очередь.

**Время работы:** $O(n \log n)$
