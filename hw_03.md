### Алгоритмы и структуры данных, ДЗ №3

Новожилов Дмитрий, гр. 504

---

#### №5

Заводим два указателя `l=0`, `r=2`. Пусть `d(l, r)` -- функция, считающая расстояние между точками `a[l]` и `a[r]`.
Алгоритм: сдвигаем `r` до тех пор, пока `d(l, r)` увеличивается. Как только `d(l, r)` начинает уменьшаться, начинаем сдвигать `l`, пока `d(l, r)`, увеличивается, далее снова сдвигаем `r` и т.д. На каждом шаге поддерживаем максимальное найденное расстояние и соответсвтующие `l` и `r`. Как `l` и `r` дойдут до значений `l=n-3`, `r=n-1`, заканчиваем алгоритм.

#### № 6

Исходный массив `a`. Заводим массив `b` заполненный нулями. Далее, для каждого запроса `add(x, l, r)` изменяем массив `b` следующим образом: `b[l] += x, b[r+1] -= x`. После заполнения массива `b` вычисляем новые значения в массиве `a` следующим образом:
```python
c = 0
for i in range(len(a)):
    c += b[i]
    a[i] += c
```
После данного алгоритма в массиве `a` будут храниться значения после всех выполенных операций.

Время предподсчета массива `b` -- $O(m)$, время изменения массива `a` -- $O(n)$, суммарное время работы -- $O(n+m)$.

#### № 7

Заводим два указателя `l` и `r`, а также массив `b` размера `n`, в котором для каждого числа будем хранить, сколько раз оно встречалось на отрезке `[l, r]`. Изначально `l` и `r` указывают на первый элемент массива `a`. Также заводим переменную `m`, в которой хранится количество уникальных элементов на отрезке `[l, r]`.
Алгоритм: сдвигаем `r` вправо, обновляя `b` и `m` согласно их определениям до тех пор, пока `m` не станет равно `k`. После этого сдвигаем `l` вправо (обновляя `b` и `m`) до тех пор, пока `m` не начнет уменьшаться. Значения `l` и `r`, при которых `m(l, r) = k, m(l+1, r) = k-1`  сохраняем в ответ.
Далее повторяем алгоритм (снова сдвигаем `r` и т.д.), каждый новый ответ сравниваем с уже найденным и обновляем, если расстояние между `l` и `r` меньше, чем между сохраненными значениями. По завершении выводим ответ (отсутствие ответа можно проверить булевским флагом, который переключается в `True` при первом найденном ответе).

#### № 8

Проверяем последовательность скобок, попутно добавляя правильные парные скобки в буффер. При найденном нарушении правильности скобок записываем в буффер ответ, сбрасываем буффер и стек, идем дальше.

```python
def find(s: str):
    def empty():
        return ['' for _ in range(len(s))], len(s) + 1, 0

    bracers = {'(': ')', '{': '}', '[': ']'}

    res, res_start, res_len = empty()
    buf, buf_start, buf_len = empty()
    stack = []

    for i, c in enumerate(s):
        if c in bracers:
            stack.append((i, c))
        else:
            if len(stack) == 0:
                continue
            l, op = stack.pop()
            if c == bracers[op]:
                # последовательность правильная, добавляем в ответ
                buf[i] = c
                buf[l] = op
                buf_len += 2
                buf_start = min(buf_start, l)
            else:
                # последовательность неправильная
                if buf_len > res_len:
                    # если ответ в буффере больше найденного,
                    # то обновляем найденный
                    res, res_start, res_len = buf, buf_start, buf_len
                # сбрасываем буффер и стек
                buf, buf_start, buf_len = empty()
                stack = []

    if buf_len > res_len:
        res, res_start, res_len = buf, buf_start, buf_len

    res_s = ''
    for c in res[res_start:res_start + res_len]:
        res_s += c
    return res_s
```
