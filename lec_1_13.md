## Минимальные остовные/покрывающие деревья (minimal spaning tree)

### Теорема о разрезе

Пусть $T \subset M$, $M$ -- MST ($T$ -- остовный лес). $V = V_1 \sqcup V_2$ -- разрез $T$, не пересекающий ребер $T$.

**Утверждение:** пусть $e$ -- минимальное ребро, пересекающее разрез. $T\cup \{e\} \subset M'$, $M'$ -- тоже MST.

**Доказательство:** Рассмотрим $M$, $e\notin M$. Пусть $H = M\cup \{e\}$. В $H$ есть цикл (т.к. $M$ это уже остовное дерево) $\Rightarrow \exists e'$, ребро, пересекающее разрез. $\omega(e) \leq \omega(e') \Rightarrow$ если выкинуть из дерева $e'$ и добавить $e$, мы либо получим дерево такого же веса (что хорошо), либо получим дерево веса меньше, чем у минимального остовного (это значит, что нет минимальных остовных деревьев, которым не принадлежит $e'$)


### Алгоритм Прима

Берем минимальное ребро. Дальше на каждом шаге мы к уже готовому дереву добавляем ребро, смежное с этим деревом.

Т.к. дерево покрывает все вершины, можно начать с дерева, содержащего только одну вершину (e.g. первую), и начать растить дерево с него.

По сути, Дейкстра с другой метрикой.

```python
def prim():
    dist = [inf for _ in range(n)]
    prev = [0 for _ in range(n)]

    pq = priority_queue()
    # пара (вершина, дистанция (вес мин. ребра))
    pq.insert((0, 0))
    while len(pq) > 0:
        v, d = q.extract_min()
        for u, w in g[v]:
            if dist[u] == inf:
                dist[u] = w
                prev[u] = v
                pq.insert(u, w)
            elif dist[u] > w:
                dist[u] = w
                prev[u] = v
                pq.decrease_key(u, w)

    T = ... # итоговое дерево
    for v in range(1, n):
        T += (prev[v], v)

    return T
```

**Сложность алгоритма:** такая же, как и у Дейкстры:
1. $O(V^2)$ -- очередь на массиве
2. $O(V+E\log(V))$ -- очередь на бинарной куче
3. $O(E)$, если $E\sim V^{1+\varepsilon}$ -- очередь на d-ичной куче.

### Алгоритм Краскала

Изначально есть остовный лес из $n$ вершин, без ребер. Растим его, на каждом шаге добавляя ребро с минимальным весом, концы которого лежат в разных деревьях.

Используем *систему непересекающихся множеств*, описание `make_set`, `find` и `union` см. ниже.

```python
def kruskal():
    es.sort(key=lambda e: e.w)  # es -- множество ребер
    for v in range(n):
         make_set(v)
    T = ...  # пустое дерево
    for e in es:
        s1 = find(e.v)
        s2 = find(e.u)
        if s1 != s2:
            union(s1, s2)
            T += e

    return T
```

**Сложность алгоритма:** если веса ребер из целочисленного диапазона, то отсортировать их за $O(E)$, также ребра могут быть заранее отсортированы. В таком случае алгоритм будет работать за $O(V + E\log^* V)$
