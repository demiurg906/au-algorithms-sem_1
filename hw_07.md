### Алгоритмы и структуры данных, ДЗ №7

Новожилов Дмитрий, гр. 504

---

#### №1

Пусть $D_n^k$ -- число n-значных чисел с суммой цифр равной k.

Число счастливых билетов $T_{2n} = \sum \limits_{k=0}^{9\cdot n} \left(D_n^k\right)^2$.

Рекуррентное соотношение: $D_n^k = \sum\limits_{i=0}^9 D_{n-1}^{k-i}$ -- n-значное число с суммой цифр k -- цифра ;i в начале + n-1-значаное число с суммой цифр $k-i$.
Граничные условия:
* $D_0^0 = 1$
* $D_n^k = 0, \ \text{если} \ k < 0 \ \text{или} \ k > 9\cdot n$

Алгоритм: заполняем таблицу $D$ (можно хранить только текущий и предыдущий столбцы для экономии памяти), после чего суммируем квадраты последнего столбца.

#### №2

$\alpha_i$ -- азимут каждого пирата, $\alpha_0 = \alpha$ -- начальный азимут пушки.
Введем массив $\tau_i$ -- время, в которое $i$-й корабль был застрелен пушкой.
Также будем хранить массив флагов, символизирующий о том, убит соответствующий корабль или нет.

Отсортируем $\alpha_i$ и $t_i$ по возрастанию $t_i$.

Пусть посчитаны все $\tau_i$ до $\tau_n$. Рассмотрим $n+1$-й корабль. Если он уже уничтожен ранее, то все хорошо, $\tau_{n+1} = \tau_n$ (корабль может быть уничтожен пушкой, когда она поворачивалась, чтобы уничтожить какой-то предыдущий корабль). В противном случае, чтобы уничтожить $n+1$-й корабль, пушка может провернуться либо от последнего своего положения (см. $\tau_{n+1}'$), либо от какого-то более раннего положения $i$, уничтожить его и вернуться обратно, чтобы потом повернуться в другую сторону и уничтожить $i+1$-й корабль (см. $\tau_{n+1}''$).
$\tau_{n+1}' = \tau_n + \omega\cdot|\alpha_n - \alpha_{n+1}|$
$\tau_{n+1}'' = \tau_n + \Delta\tau_{n+1}$, где $\Delta\tau_{n+1} = \min(\Delta t_i) = \min(\tau_i + 2\omega\cdot|\alpha_i-\alpha_{n+1}|)$, среди всех $i < n$ таких, что $\tau_j + \Delta t_i \leq t_j \ \forall i < j < n$ (с новыми затратами времени на $n+1$ корабль мы все-равно должны успеть уничтожить предыдущие).
Если $\tau_{n+1}' < \tau_{n+1}''$, то $\tau_{n+1} = \tau_{n+1}'$, и мы просто поворачиваем пушку в новое положение.
В противном случае $\tau_{n+1}=\tau_{n+1}''$, и все $\tau_i$ от номера, который был выбран при минимуме в расчете $\Delta\tau_{n+1}$ и до $n$ надо увеличить на $\Delta\tau_{n+1}$.

Чтобы отмечать, какие корабли дополнительно уничтожаются при повороте пушки с позиции $k$ на позицию $l$, можно завести отсортированную копию массива $\alpha_i$ ($\beta_i$, например), и при повороте с помощью двух бин. поисков находить все корабли, лежащие между $\alpha_k$ и $\alpha_l$ и помечать их как уничтоженные в массиве флагов.

Т.к. для расчета каждого $\tau_i$ мы максимум четыре раза (поиск минимума, проверка условия, увеличение $\tau$, отметка сбитых кораблей) пробегаем по массивам длины n, то время работы $O(n^2\log n)$.

Чтобы избавить от бин. поиска и логарифма, можно вместо массива флагов хранить направление, в котором поворачивается пушка и $\Delta t_i = 0$, если направление при повороте $i \rightarrow i+1$ совпадает с направлением $i \rightarrow n + 1$.
В таком случае время работы будет $O(n^2)$.

**Почему это работает:**

В представленном алгоритме для каждого корабля вычисляется, в какой момент его можно уничтожить так, чтобы затратить на это как можно меньшее время.

Возможно я слишком громоздко расписал, поэтому идея алгоритма кратко: сортируем пиратов по времени прилета, фиксируем время и азимут пушки при уничтожении $i$-того пирата. При рассмотрении каждого нового пирата, пытаемся уничтожить его из какого-то из ранних положений пушки ($k$) так, чтобы затратить на поворот как можно меньше времени и при этом успеть уничтожить всех пиратов с индексами большке $k$.

#### №3

Заведем массив `s` такой, что в каждом элементе массива будет храниться множество (булев массив размера $g$) элементов, которые можно получить, расставив скобки в последовательности $a_1...a_i$. Очевидно, что `s[1]` -- множество, состоящее из элемента $a_1$.

Пусть известны все `s[i]` для `i` до `n-1`. Когда мы добавляем $a_n$ к последовательности, скобки можно расствить такими способами: $(s_{n-1})\cdot (a_n), \ (s_{n-2})\cdot (a_{n-1} \cdot a_n), \ ...\  ,\ (a_1 \cdot...\cdot a_n)$ (в данном выражении $s_i$ -- последовательность длины $i$ с как-то расставленными в ней скобками).
Отсюда можно понять, как вычислять `s[n]`: `s[n]` -- это пересечение множеств вида $\{(a_{n-i+1}\cdot...\cdot a_n) \cdot x | x \in s[i]\}$. Вычисление $(a_{n-i+1}\cdot...\cdot a_n)$ занимает $O(n)$ времени. Вычисление одного множества из пересечения занимает время $O(g)$ (в множестве всего $g$ элементов). Вычисление пересечения всех таких множеств -- $O(n\cdot g)$. Всего элементов в `s` -- $n$ штук -- соответственно время работы алгоритма $O(n^3g^2)$.

#### №4

Пусть $P(m, l)$ -- вероятность того, что после подбрасывания первых $m$ монет выпало $l$ орлов. Тогда $P(m, l) = P(m-1, l-1)\cdot c_l + P(m-1, l)\cdot (1-c_l)$ -- либо выпал орел, значит нас интересует вероятность того, что до этого выпало $l-1$ орлов, либо орел не выпал $\rightarrow$ интересна вероятность, что мы уже получили $l$ орлов.
Граничные условия: $P(1, 1) = c_1$, $P(m, l) = 0, \ l > m$.

Алгоритм заполняем массив `p[m, l]` в соответствие с рекуррентной формулой, ответ хранится в ячейке `p[n, k]`.

#### №5

`w[i]` -- массив стоимостей подарков.

Заведем бинарный массив `d[i][k]`, показывающий, можно ли набрать подарков стоимости `k` из первых `i` подарков. `d[i][k] = d[i-1][k-w[i]]`, `d[0][0] = 1`.
Время заполнения этого массива $O(nW)$.

Далее переберем все пары `w1, w2: w1 + w2 < W` и будем минимизировать величину `max(w1, w2, W - w1 - w2) - min(w1, w2, W - w1 - w2)`, при условии, что `d[n][w1] = True`, `d2 = d[n][w2] = True`, `d3 = d[n][W - w1 -w2] = True`).

Соответствующие этому минимуму `w1`, `w2`, `W - w1 - w2` и будут ответом.

#### №6

Пусть $d[l][r]$ -- стоимость бинарного поиска на подотрезке $[l, r+1]$ исходного массива. База для заполнения $d[l][l + 1] = 0$ (на отрезке размера 1 просто возвращается элемент). Для произвольного отрезка $d[l][r] = \max(c_m + \max(d[l][m], d[m][r])),\ l\leq m\leq r$.
Ответ будет находиться в ячейке $d[0][n]$.

Массив размера $n\times n$, время вычисления одного элемента $O(n) \Rightarrow$ время работы алгоритма $O(n^3)$.
