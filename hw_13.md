### Алгоритмы и структуры данных, ДЗ №13

Новожилов Дмитрий, гр. 504

---

#### №1

Если у нас уже есть минимальный остов, то получить другой остов можно, если добавить к данному какое-нибудь ребро $(v, u)$, и удалить какое-нибудь ребро из дерева на пути из $v$ в $u$.

Из каждой вершины в дереве запускаем $BFS$, для того, чтобы найти ребро максимального веса на пути из $v$ в $u$ для всех пар $(v, u)$ -- массив $d[v, u]$. После этого ищем такую пару вершин, что $\Delta(v, u) = \omega(v, u) - d[v, u]$ -- минимальна (все $\Delta \geq 0$, т.к. в противном случае можно было бы получить остов веса меньше минимального). Если из минимального остова убрать ребро, лежащее в $d[u, v]$, и вместо него добавить ребро $(u,w)$, то получится второй минимальный остов.

Почему работает: допустим, что второй остов можно получить только заменой нескольких ребер в минимальном остове. Значит вес второго остова будет отличаться от веса первого на величину $\sum\limits_{i=1}^k \Delta(v_i, u_i) = \sum\limits_{i=1}^k \omega(v_i, u_i) - d[v_i, u_i]$. Но тогда можно взять пару вершин, для которых $\Delta$ минимальна, и заменить ребра только для нее, и тогда получится остов веса больше минимального, но меньше найденного. Противоречие.

**Update:**

**Утверждение:** Если в минимальный остов добавить ребро из графа, которое ему не принадлежит, то в остове обнаружится цикл. Если теперь этот цикл порвать, убрав ребро из остова, то новый остов по весу будет не лучше минимального. Это очевидно, т.к. минимальный остов, как ни странно, минимальный.

Более полное доказательство того, что второй остов отличается от перовго только одним ребром:

Пусть $T_1$ и $T_2$ -- первый и второй остовы соответственно, между ними разница в $k>2$ ребер (они совпадают по $n-1-k$ ребрам). Добавим в $T_1$ те ребра из $E(T_2)\setminus E(T_1)$. Т.о. в дереве образуется $k$ циклов. Эти циклы можно починить, если убрать из получившегося графа ребра из $E(T_1)\setminus E(T_2)\ \Rightarrow$ в каждом цикле $i$ есть ребра $e_{1_i}\in E(T_1),\ e_{2_i}\in E(T_2)$. Таким образом мы можем из этого графа убрать все циклы, убирая для всех циклов, кроме одного, ребра $e_{2_i}$, и только для одного $e_{1_i}$. Т.о. мы получим остовное дерево, которое по весу не лучше $T_1$ и не хуже $T_2\ \Rightarrow$ мы получим второй остов веса $\leq$ веса $T_2$. Если строго $=$, то все хорошо, мы просто нашли второй остов того же веса, что и $T_2$, но отличающийся только на одно ребро от $T_1$; если строго меньше, то противоречие. Т.о. утверждение доказано.

Время работы: нахождение $d[v, u]$ -- $O(V^2)$ ($V$ раз запускается $BFS$), нахождение минимума $\Delta$ -- $O(E)$ (пробегаем по всем ребрам). Итого $O(V^2 + E)$.

#### №2

Данный алгоритм работает, т.к. это в точности алгоритм Краскала наоборот.

Доказательство: допустим, у нас уже есть дерево, построенное алгоритмом Краскала. Пойдем по ребрам графа в порядке невозрастания. Рассматриваем очередное ребро $e$.
1. Удаление $e$ не приводит к появлению новой компоненты связности $\Rightarrow$ когда алгоритм Краскала дошел до этого ребра, то он не добавил его в дерево, т.к. добавление этого ребра к лесу не уменьшило число деревьев $\Rightarrow$ ребро $e$ не лежит в дереве и его можно выкидывать.
2. Удаление $e$ приводит к появлению новой компоненты связности $\Rightarrow$ Краскал добавил это ребро в дерево, т.к. оно уменьшило число деревьев в лесу $\Rightarrow$ ребро $e$ принадлежит дереву.

#### №4

1. Пусть наш граф называется $G$, дерево Штейнера, построенное на терминалах -- $T_{ST}$. Удвоим в $T_{ST}$ все ребра и из произвольной терминальной вершины пройдемся по всем вершинам гамильтоновым путем. Вес данного пути будет равен $2\cdot\omega(T_{ST})$.
    Рассмотрим произвольный цикл $C$ через все вершины из $T$ в графе $G$. Очевидно, что он проходит только по вершинам из $T$, т.к. на весах $G$ выполняется неравенство треугольника. В силу неравенства треугольника вес ребра $\omega(t_i, t_{i+1}) \leq \omega((t_i, t_{i+1})_ {T_{ST}})$ веса пути между $t_i$ и $t_{i+1}$  в дереве $T_T$ в порядке вышеописанного обхода. Т.о. $\omega(C) \leq 2\cdot\omega(T_{ST})$. Если из $C$ удалить какое-нибудь ребро, то получится какое-то минимальное дерево на терминальных вершинах. Оно не больше того минимального, которое построено каким-нибудь алгоритмом $\Rightarrow\ \omega(MST) \leq 2\cdot\omega(T_{ST})$.
2. .......

#### №5

Найдем какое-нибудь минимальное остовное дерево алгоритмом Краскала (его вес, очевидно, $\omega$). После этого будем искать другой остов алгоритмом из первого пункта, но будем игнорировать ребра $(v, u)$, у которых $\Delta(v, u) = 0$ (т.к. при замене минимального остова на новый через ребро $(v, u)$ мы получим новый остов того же веса, ибо $\Delta(v, u)$ как раз показывает, насколько увеличится вес минимального остова при соответствующем преобразовании.
