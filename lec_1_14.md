### Система непересекающихся множеств (Disjoint sets)

**Операции:**
```python
make_set(v)   # создание нового множества
find(v)       # принимает вершину и возвращает представителя его множества
union(s1, s2) # объединяет два множества
```

**Реализация:**
```python
parent = [None for _ in range(n)]
rank = [0 for _ in range(n)]  # высота дерева множества

# O(1)
def make_set(v):
    parent[v] = v
    rank[v] = 0

# O(log n)
# возвращает корневую вершину эл-та v
def find(v):
    while v !=  parent[v]:
        v = parent[v]
    return v

# O(1)
# s1 и s2 -- корневые вершины
def union(s1, s2):
    if rank[s1] > rank[s2]:
        parent[s2] = s1
    elif rank[s1] < rank[s2]:
        parent[s1] = s2
    else:
        parent[s1] = s2
        rank[s2] += 1
```

**Утверждение:** у корня с рангом $k$ не менее, чем $2^k-1$ потомка (у соотв. множества не менее, чем $2^k$ элементов).
**Док-во:** по индукции. База очевидна. **И.п.**: есть два корня с не менее чем $2^k-1$ потомками; из реализации видно, что ранг у корня объединения будет не менее $(2^k-1) + (2^k-1) + 1 = 2^{k+1} - 1$.

Аналогично можно доказать, что у дерева с корнем ранга $k$ глубина равняется $k$.

**Следствие:** `find` для СНМ с рангами работает за $O(\log n)$.

##### Эвристика сжатия пути

```python
def find(v):
    if v !=  parent[v]:
        parent[v] = find(parent[v])
    return parent[v]
```

Замечания:
1. Ранги не соответствуют высоте дерева
2. Утверждение про минимальное количество элементов в дереве осталось верным
3. Если вершина перестала быть корневой, то ее ранг зафиксировался и больше не изменится
4. Ранг вершины может только увеличиваться
5. `rank[parent[v]] > rank[v]`

**Утверждение:** вершин ранга $k$ не более, чем $\frac n {2^k}$.

**Время работы:** Предположим, что мы делаем $m\geq n$ операций `find` на СНМ размера $n$. Эти $m$ вызовов `find` требуют $O(m\cdot\log^* n)$ операций $\Rightarrow$ амортизированное время работы `find` -- $O(\log^* n)$
**Доказательство:** разобьем ранги на промежутки $[0], [1], [2], [3, 2^2], [5, 6,..., 2^4], [16+1,...,2^{16}], [65537,...,2^{65536}],...,[k+1,...,2^k]$.
Этих промежутков $\log^* n$ штук.

В СНМ есть два типа ребер -- внутренние и внешние. Внутреннее ребро -- `rank[v]` и `rank[parent[v]]` лежат в одном промежутке. Внешнее ребро -- ранги в разных промежутках.
`find` может заменить внутреннее на внешнее, но не обратно.

**Утверждение:** в каждой рекурсивной цепочке `find` не более $\log^* n$ внешних ребер (т.к. больше промежутков нет).

**Утверждение:** любая вершина ранга из промежутка $[k+1,...,2^k]$ учавствует в не более чем $2^k$ переходов по внутренним ребрам (больше значений в промежутке нету).

**Утверждение:** в каждом промежутке происходит не более $n$ переходов по внутренним ребрам: промежутков $[k+1,...,2^k]$ штук; переходов: $\sum\limits_{i=k+1}^{2^k\approx \infty} 2^k\cdot \frac n {2^i} = \frac n 2 + \frac n 4 + \frac n 8 + ... \leq n$ штук.

**Итого:** $m$ операций `find`.
Число переходов по ребрам: $m$ переходов по ребрам, из которых $m\cdot\log^* n$ переходов по внешним ребрам, $n\cdot\log^* n$ переходов по внутренним ребрам $=O(m\log^* n)\ \Rightarrow$ амортизированная стоимость одной операции `find`: $O(\log^* n)$.

Страница на [neerc.ifmo](http://neerc.ifmo.ru/wiki/index.php?title=%D0%A1%D0%9D%D0%9C_(%D1%80%D0%B5%D0%B0%D0%BB%D0%B8%D0%B7%D0%B0%D1%86%D0%B8%D1%8F_%D1%81_%D0%BF%D0%BE%D0%BC%D0%BE%D1%89%D1%8C%D1%8E_%D0%BB%D0%B5%D1%81%D0%B0_%D0%BA%D0%BE%D1%80%D0%BD%D0%B5%D0%B2%D1%8B%D1%85_%D0%B4%D0%B5%D1%80%D0%B5%D0%B2%D1%8C%D0%B5%D0%B2)).
