### Алгоритм Эдмондса-Карпа

**Время работы:** $O(V\cdot E^2)$
Минусы Ф.Ф.:

* при больших пропускных способностях алгоритм перестает быть полиномиальным
* при иррациональных весах алгоритм может не завершиться

Т.к. алгоритм Ф.Ф. не идеален, был придумал *алгоритм Эдмондса-Карпа*.

**Суть:** в схеме ФФ ищем кратчайший по количеству ребер путь в остаточной сети (поиском в ширину) $\Rightarrow$ алгоритм работает для вещественных весов и полиномиально.

**Лемма:** пусть расстояние $D_i(v)$ -- количество ребер от $s$ до $v$ в остатончоной сети на $i$-й итерации. Тогда $\forall i\ \ D_i(v) \geq D_{i-1}(v)$
**Доказательство:** от противного. Допустим, что на итерации $i$ $v$ приблизилась к $s$. Тогда $v$ -- ближайшая к $s$ вершина, которая приблизилась. Пусть $(u, v)$ -- ребро на этом пути.
1. $D_i(v) = D_i(u) + 1$
2. $D_i(v) < D_{i-1}(v)$
3. $D_i(u) \geq D_{i-1}(u)$

**Утверждение:** ребро $(u, v)$ не содержалось в $C_{f_{i-1}}$
**Доказательство:** от противного. Пусть было $D_{i-1}(V) \leq D_{i-1}(u) + 1 \leq D_i(u) + 1 = D_i(v)$. Конфликт с пунктом 1 из леммы.

<span style="color:red">тут произошла магия, которую я упустил</span>

$D_{i-1}(v) + 1 = D_{i-1}(u)$

$D_i(v) = D_i(u) + 1 \geq D_{i-1}(u) + 1 = D_{i-1} + 2$. Противоречие, лемма доказана.

**Теорема:** алгоритм Э.К. работает за $O(VE^2)$.
**Доказательство:** рассмотрим кратчайшее ребро на $i$-ой итерации -- это минимальное ребро на дополняющем пути минимальной пропускной способности. Больше этого ребра по потоку не послать, и при этом после пускания по нему потока оно уходит из остаточной сети: если $(u, v)$ -- критическое на итерации $i$, то $(u, v)\notin G_{f_{i + 1}}$

**Утверждение:** каждое ребро не может быть критическим более $\frac{|V|}2$ раз.
**Доказательство:** пусть $(u, v)$ критическое на итерациях $t_1$ и $t_2$. Тогда $D_{t_1}(u) + 1 = D_{t_1}(v)$ и $D_{t_2}(u) + 1 = D_{t_2}(v)$. Тогда существует $t':\ \ t1 < t' < t_2$ такое, что $(v, u)$ лежало в дополняющем пути. Т.е. $D_{t'}(v) + 1 = D_{t'}(u)$.

$D_{t_2}(v)= D_{t_2}(u) + 1 \geq D_{t'}(u) + 1 = D_{t'}(v) + 2 \geq D_{t_1}(v) + 2$. Таким образом каждый раз к $D_i(v)$ прибавляется как минимум двойка и $D_t(v) \leq |V| \Rightarrow$ каждое ребро критическое не больше $\frac{|V|}2$ раз.

Всего итераций $\leq \frac{|V|}2\cdot |E| 2 = O(VE)$ и каждая итерация занимает $O(V + E)$ (кратчайший путь ищем поиском в ширину). Итого получаем, что суммарное время $O(VE^2)$

# Алгоритмы на строках

## Поиск подстроки

Вход: $T$ -- текст, $P$ -- шаблон. $|T| = n$, $|P| = m$.
Выход: первое/все вхождения $P$ в $T$.

**Наивный алгоритм:** $O(nm)$

**Алгоритм Рабина-Карпа:** этот тот алгоритм, что с хешами. В среднем $O(n + m)$

### Z-функция

*Z-функция* для строки $S$ -- это массив $z$ длины $|S|$ такой, что $z[i]$ -- длина максимального префикса $S$, который начинается позиции $i$ (т.е. префикс $S$ совпадает с подстрокой $S[i:]$).

**Пример:**
`s = abcabcdabcabcabcd`
`z = 00030006007003000` (в первой ячейке формально находится длина строки, но первая ячейка никому не нужна)

**Мотивация:** если мы можем вычислить $Z(S)$ за $O(|S|)$, то можно найти все вхождения $P$ в $T$ за $O(n + m)$
**Доказательство:** вычислим $Z(P\$T)$ ($\$$ не встречается в $P$ и $T$). Во всех местах $Z$ функции, где $z[i] = |P|$ находятся матчи с $P$.

Алгоритм поиска $Z$-функции не очень сложный, его можно посмотреть, например [здесь](https://neerc.ifmo.ru/wiki/index.php?title=Z-%D1%84%D1%83%D0%BD%D0%BA%D1%86%D0%B8%D1%8F) и [здесь](http://e-maxx.ru/algo/z_function).

### Алгоритм Кнута-Морриса-Пратта (КМП)

$\pi$ -- *префикс-функция* строки $S$, $\pi[i]$ -- длина максимального суффикса $S[0:i - 1]$, который является префиксом

В наивном алгоритме, зная $\pi(S)$ можно при несовпадении сдвигаться по $S$ не на $1$, а на значение префикс функции. Таким образом каждый символ из $S$ мы просмотрим максимум два раза.

**Пример:**
```
 s = abcabcdabcabcabcd
 z = 00030006007003000
pi = 00012301234564567
```

**Замечание:** $\pi(P\$T)$ также позволяет найти все вхождения

**Как искать префикс функцию:**
```python
def prefix(s):
    n = len(s)
    k = 0  # количество совпавших символов
    pi = [0, ...]
    for i in range(2, n):
        while k > 0 and s[i] !- s[k + 1]:
            k = pi[k]
        if s[i] == s[k + 1]:
            k += 1
        pi[i] = k
    return pi
```

**Поиск по префиксу:**
```python
def search(t, p):
    pi = prefix(p)
    k = 0
    for i in range(len(t)):
        while p[k + 1] != t[i]:
            k = pi[k]
        if p[k + 1] == t[i]:
            k += 1
        if k == len(p):
            return i
    return -1
```

**Подсчет префикс-функции работает за $O(n)$:**
На каждом шаге $pi$ увеличивается не более чем на $1$. Внешний цикл работает за линию. По всем итерациям `for` `while` проводит не более $n$ итераций. Итого время $O(n)$. Строго доказать можно через метод потенциалов.

### Алгоритм Ахо-Корасика

На вход подается набор шаблонов $\{P_i\}$. Задача: для любого текста $T$ быстро $O(|T| + \#\text{вхождений}$) проверить, есть ли вхождения шаблонов из набора в этот текст.

**Где используется:** в антивирусах.

*Алгоритм Ахо-Корасика* строит *Бор* -- веселое дерево, в котором хранятся все шаблоны. Бор строится за $O\left(\sum|P_i|\right)$ при константном размере алфавита. Необходимая память: $O\left(\sum|P_i|\cdot |\Sigma|\right)$.

Хочется не только искать по бору, но и возвращаться по префиксам. Для этого нужно на бор навесить еще ребер:
* суффиксное ребро -- отсылает к максимальному префиксу, который совпадает с суффиксом текущей строки (та же идея, что и с префикс-функцией).
    **Построение:** идем поиском в ширину от корня. Когда проходим по ребру $(u, v)$ с символом $c$ идем по суффиксной стрелке $u$ и пытаемся пройти по символу $c$. Если получилось, проводим суффиксную стрелку, иначе идем по суффиксной стрелке той вершины, в которую мы зашли (и так, пока не будет успеха). Это все дело работает за $O\left(\sum|P_i|\right)$.
* сжатые суффиксные ребра -- ссылка до ближайшейго терминала, который достижим по суффиксным ссылкам. Строятся также за $O\left(\sum|P_i|\right)$, позволяют для любого состояния найти все паттерны, на которые получилось заматчится.
