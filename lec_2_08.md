# Алгоритмы на строках

## Поиск подстроки

Вход: $T$ -- текст, $P$ -- шаблон. $|T| = n$, $|P| = m$.
Выход: первое/все вхождения $P$ в $T$.

**Наивный алгоритм:** $O(nm)$

**Алгоритм Рабина-Карпа:** этот тот алгоритм, что с хешами. В среднем $O(n + m)$

### Z-функция

*Z-функция* для строки $S$ -- это массив $z$ длины $|S|$ такой, что $z[i]$ -- длина максимального префикса $S$, который начинается позиции $i$ (т.е. префикс $S$ совпадает с подстрокой $S[i:]$).

**Пример:**
`s = abcabcdabcabcabcd`
`z = 00030006007003000` (в первой ячейке формально находится длина строки, но первая ячейка никому не нужна)

**Мотивация:** если мы можем вычислить $Z(S)$ за $O(|S|)$, то можно найти все вхождения $P$ в $T$ за $O(n + m)$
**Доказательство:** вычислим $Z(P\$T)$ ($\$$ не встречается в $P$ и $T$). Во всех местах $Z$ функции, где $z[i] = |P|$ находятся матчи с $P$.

Алгоритм поиска $Z$-функции не очень сложный, его можно посмотреть, например [здесь](https://neerc.ifmo.ru/wiki/index.php?title=Z-%D1%84%D1%83%D0%BD%D0%BA%D1%86%D0%B8%D1%8F) и [здесь](http://e-maxx.ru/algo/z_function).

### Алгоритм Кнута-Морриса-Пратта (КМП)

$\pi$ -- *префикс-функция* строки $S$, $\pi[i]$ -- длина максимального суффикса $S[0:i - 1]$, который является префиксом

В наивном алгоритме, зная $\pi(S)$ можно при несовпадении сдвигаться по $S$ не на $1$, а на значение префикс функции. Таким образом каждый символ из $S$ мы просмотрим максимум два раза.

**Пример:**
```
 s = abcabcdabcabcabcd
 z = 00030006007003000
pi = 00012301234564567
```

**Замечание:** $\pi(P\$T)$ также позволяет найти все вхождения

**Как искать префикс функцию:**
```python
def prefix(s):
    n = len(s)
    k = 0  # количество совпавших символов
    pi = [0, ...]
    for i in range(2, n):
        while k > 0 and s[i] != s[k + 1]:
            k = pi[k]
        if s[i] == s[k + 1]:
            k += 1
        pi[i] = k
    return pi
```

**Поиск по префиксу:**
```python
def search(t, p):
    pi = prefix(p)
    k = 0
    for i in range(len(t)):
        while p[k + 1] != t[i]:
            k = pi[k]
        if p[k + 1] == t[i]:
            k += 1
        if k == len(p):
            return i
    return -1
```

**Подсчет префикс-функции работает за $O(n)$:**
На каждом шаге $pi$ увеличивается не более чем на $1$. Внешний цикл работает за линию. По всем итерациям `for` `while` проводит не более $n$ итераций. Итого время $O(n)$. Строго доказать можно через метод потенциалов.

### Алгоритм Ахо-Корасика

На вход подается набор шаблонов $\{P_i\}$. Задача: для любого текста $T$ быстро $O(|T| + \#\text{вхождений}$) проверить, есть ли вхождения шаблонов из набора в этот текст.

**Где используется:** в антивирусах.

*Алгоритм Ахо-Корасика* строит *Бор* -- веселое дерево, в котором хранятся все шаблоны. Бор строится за $O\left(\sum|P_i|\right)$ при константном размере алфавита. Необходимая память: $O\left(\sum|P_i|\cdot |\Sigma|\right)$.

Хочется не только искать по бору, но и возвращаться по префиксам. Для этого нужно на бор навесить еще ребер:
* суффиксное ребро -- отсылает к максимальному префиксу, который совпадает с суффиксом текущей строки (та же идея, что и с префикс-функцией).
    **Построение:** идем поиском в ширину от корня. Когда проходим по ребру $(u, v)$ с символом $c$ идем по суффиксной стрелке $u$ и пытаемся пройти по символу $c$. Если получилось, проводим суффиксную стрелку, иначе идем по суффиксной стрелке той вершины, в которую мы зашли (и так, пока не будет успеха). Это все дело работает за $O\left(\sum|P_i|\right)$.
* сжатые суффиксные ребра -- ссылка до ближайшейго терминала, который достижим по суффиксным ссылкам. Строятся также за $O\left(\sum|P_i|\right)$, позволяют для любого состояния найти все паттерны, на которые получилось заматчится.
