# Деревья поиска

Хочется заиметь структуру данных, которая умеет быстро отвечать на запросы, находится ли элемент $x$ в множестве. Области применения -- `Set`, `Map (dict)`. Возможно два случая:
1. Структура статическая (только запросы на поиск)
2. Структура динамическая (запросы на поиск + вставка и удаление)

Одним из вариантов реализации может быть *дерево поиска* -- бинарное дерево, для которого для каждого узла $x$ верно то, что слева находятся элементы $\leq x$, а справа $>x$.

Еще существует *B-дерево* -- хитрое дерево, в каждом узле которого хранится много ключей, и у каждого узла много детей. Но об этом как-нибудь в другой раз.

Реализация простого BST:

```python
class Node:
    def __init__(self, key, parent=None, left=None, right=None):
        self.parent = parent  # родитель
        self.left = left      # левый ребенок
        self.right = right    # правый ребенок
        self.key = key        # сам элемент

root = ...  # какое-то дерево

# является ли узел листом
def is_leaf(node):
    return node.left is None and node.right is None

# поиск ключа в дереве
def find(key, node=root):
    if node is None or node.key == key:
        return node
    if key < node.key:
        return find(key, node.left)
    else:
        return find(key, node.right)

# минимум в дереве
def tree_minimum(node=root):
    if node is None:
        return None
    while node.left is not None:
        node = node.left
    return node

# максимум в дереве
def tree_maximum(node=root):
    # аналогично tree_minimum

# наименьший элемент, больше текущего
def succesor(node):
    if node.right is not None:
        return tree_minimum(n.right)
    # поднимаемся только по правым ветвям
    while node.parent is not None and node.parent.left != node:
        node = node.parent
    return node.parent

# наибольший элемент, меньше текущего
def predecessor(node):
    # аналогично succesor

# вставка элемента в дерево
def insert(key):
    if root is None:
        root = Node(key)
        return
    p = root
    while True:
        if key <= p.key:
            if p.left is None:
                p.left = Node(key, p)
                return
            else:
                p = p.left
        else:
            if p.right is None:
                p.right = Node(key, p)
                return
            else:
                p = p.right

# удаление элемента из дерева
def delete(key):
    # реализация запарная, смотри на вики
    # можно просто картинками показать,
    # как это выглядит.
    # Смаль так и сделал
```

Бинарное дерево обеспечивает ответы на запросы $find$ за $O(\log h)$, где $h$ -- высота дерева. Возникает задача минимизировать высоту дерева. Если наше дерево статическое, то можно просто сделать его полным. Однако, если же дерево динамическое (т.е. можно добавлять и удалять элементы), то возникает задача о балансировке дерева.

Есть несколько вариантов, как сделать самобалансирующееся дерево:
1. *АВЛ-дерево*
2. *Splay-дерево*
3. *Красно-черное дерево*

## АВЛ-дерево

Для любого узла АВЛ-дерева верно, что $|h(left) - h(right)|\leq 1$ (высоты поддеревьев отличаются не более чем на 1).

**Утверждение:** высота АВЛ-дерева $=O(\log n)$.
**Доказательство:** пусть $M(h)$ -- минимальное число элементов в АВЛ-дереве высоты $h$. $M(h) = M(h-1) + M(h-2) + 1\ \Rightarrow\ n\geq M(h)\geq Fib(h)\sim 1.6^h\Rightarrow h = O(\log n)$.

Давайте для каждого узла хранить высоту.

Введем хитрые операции балансровки:
* **Малое левое вращение:**
    ![малое левое вращение](https://upload.wikimedia.org/wikipedia/ru/b/bc/AVL_LR.GIF)
    Данное вращение используется тогда, когда $h(b) - h(L) = 2$ и $h(C) \leq h(R)$.
* **Большое левое вращение:**
    ![большое левое вращение](https://upload.wikimedia.org/wikipedia/ru/1/16/AVL_BR.GIF)
    Данное вращение используется тогда, когда $h(b) - h(L) = 2$ и $h(C) > h(R)$.
* **Малое правое вращение:**
    ![малое правое вращение](https://upload.wikimedia.org/wikipedia/ru/e/e8/AVL_LL.GIF)
    Данное вращение используется тогда, когда $h(b) - h(R) = 2$ и $h(C) \leq h(L)$.
* **Большое правое вращение:**
    ![большое правое вращение](https://upload.wikimedia.org/wikipedia/ru/7/74/AVL_BL.GIF)
    Данное вращение используется тогда, когда $h(b) - h(R) = 2$ и $h(C) > h(L)$.

С такими замечательными операциями теперь можно замутить вставку и удаление.

Вставка выглядит также, как и в обычном BST, но теперь после того, как очередная вершина добавилась в качестве листа, нужно пройтись по всему пути от этого листа до корня, по необходимости вызывая нужные повороты. Сложность вставки $O(\log n)$.

Удаление тоже похоже: удаляем элемент как в обычно BST (не удаляйте ничего из BST, пожалуйста) и потом балансируем все, что выше тех вершин, что поменялись в процессе удаления.
